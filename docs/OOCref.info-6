This is Info file OOCref.info, produced by Makeinfo version 1.68 from
the input file OOCref.texinfo.

   This file documents the Optimizing Oberon-2 Compiler (OOC) and its
library.

   This is Edition 0.10 DRAFT, last updated 29 February 2000, of `The
OOC Library Reference Manual', for Version 1.5.1 or later of oo2c.

   Copyright (C) 1997-2000 Eric Nikitin Part II Copyright (C) 1998-2000
Michael van Acken

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: OOCref.info,  Node: Class Writer (TextRider),  Next: Class Scanner (TextRider),  Prev: Class Reader (TextRider),  Up: TextRider

Class Writer (TextRider)
........................

 - Class: Writer = POINTER TO WriterDesc
     This class provides facilities for writing various types of text.
     Note that this type does not inherit properties from any basic
     writer type; rather it uses the basic writer type associated with
     the channel it is attached to.

    Field: opt-: `SET'
          The current write options setting for the writer.  See *Note
          Summary of TextRider Constants:: for possible option values.

    Field: res-: `Msg.Msg'
          This field indicates the status of the last write operation
          (e.g., `WriteBytes', `WriteInt', `SetPos', etc.).

          Error codes are highly dependent on the channel being written
          to (and therefore on the basic riders provided for that
          channel), so you must look at the result codes for the basic
          writer that is associated with that particular channel (e.g.,
          `Files.Writer' error codes).  See the various channel types
          for details of these error codes (i.e., *Note Files::, *Note
          StdChannels::, or *Note ProgramArgs::).

          If `res#done', use either `res.GetLText()' or `res.GetText()'
          to get a plain text error description corresponding to the
          error code.

    Field: base-: `Channel.Channel'
          This field refers to the channel the writer is connected to.

   The following methods can be used to check the status of a writer
or, in some cases, change its state.  Some methods are fully described
in the abstract writer section (*note Abstract Class Writer::.), so
only brief descriptions of those are given here.

Method: `(W: Writer)' ClearError
     Clears error conditions on the writer W, re-enabling further write
     operations.

Method: `(W: Writer)' Pos `() : LONGINT'
     Returns the current writing position associated with the writer
     `w' in channel `W.base'.

Method: `(W: Writer)' SetEol `(MARKER: ARRAY OF CHAR; MARKERLEN: INTEGER)'
     This method sets the end-of-line marker; that is, what
     character(s) is used to mark the end of a line.  If the passed
     string MARKER does not fit into the field `eol', then `W.res.code'
     is set to `invalidFormat'.  The empty marker is permitted.  The
     default value for a newly created writer is `CharClass.systemEol'.

     *Pre-condition*: All of the following apply:
       1. `w.res = done', and

       2. `0 <= markerLen < LEN (marker)', and

       3. `markerLen <= maxLengthEol'.

Method: `(W: Writer)' SetOpts `(OPTS: SET)'
     This method is used to set the writer options `W.opt'.  See *Note
     Summary of TextRider Constants:: for possible option values.

     *Example:*

          w.SetOpts({TextRider.noBuffering});
             => output is not buffered.
          w.SetOpts(TextRider.defWriterOptions);
             => writer options set to default values.

Method: `(W: Writer)' SetPos `(NEWPOS: LONGINT)'
     Sets the writing position to NEWPOS.

   The following writer methods are used to write values in text format
to the underlying channel.  In some situations, it is possible for only
part of the value to be actually written.

Method: `(W: Writer)' WriteBool `(BOOL: BOOLEAN)'
     Writes the value of BOOL as text.  That is, either `TRUE' or
     `FALSE'.

Method: `(W: Writer)' WriteChar `(CH: CHAR)'
     Writes a single character value CH.

     *Example:*

          w.WriteChar("A");
             => writes one character = "A"

Method: `(W: Writer)' WriteHex `(LINT: LONGINT; D: LONGINT)'
     Writes the value of LINT as an unsigned hexadecimal number with a
     minimum field width of D.  Leading zeros are written if the value
     of LINT requires less than D places.  If D is less than or equal
     to zero, field width is 8.

     *Example:*

          w.WriteHex(127, 3);
             => writes "07F"
          w.WriteHex(127, 0);
             => writes "0000007F"
          w.WriteHex(-128, 0);
             => writes "FFFFFF80"

Method: `(W: Writer)' WriteInt `(INT: INTEGER; N: LONGINT)'
     Writes the value of INT as a decimal number with a minimum field
     width of N.  Leading spaces are written if the value of INT
     requires less than N places.  A sign is written only for negative
     values.

     *Example:*

          w.WriteInt(54321, 0);
             => writes "54321"
          w.WriteInt(54321, 10);
             => writes "     54321"

Method: `(W: Writer)' WriteLInt `(LINT: LONGINT; N: LONGINT)'
     This method provides the same facility as `WriteInt', except that
     it deals with `LONGINT' values.

Method: `(W: Writer)' WriteSInt `(SINT: SHORTINT; N: LONGINT)'
     This method provides the same facility as `WriteInt', except that
     it deals with `SHORTINT' values.

Method: `(W: Writer)' WriteReal `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a floating-point number with a minimum
     field width of N.

     If the value of K is greater than 0, that number of significant
     digits is included.  Otherwise, an implementation-defined number
     of significant digits is included.  The decimal point is not
     included if there are no significant digits in the fractional part.

     The number is scaled with one digit in the whole number part.  A
     sign is included only for negative values.

     *Example:*

          w.WriteReal(3923009, 0, 0);
             => writes "3.923009E+6"
          w.WriteReal(3923009, 0, 1);
             => writes "4E+6"
          w.WriteReal(3923009, 0, 4);
             => writes "3.923E+6"
          w.WriteReal(3923009, 10, 1);
             => writes "      4E+6"
          
          w.WriteReal(-39.23009, 12, 2);
             => writes "     -3.9E+1"
          w.WriteReal(-39.23009, 1, 5);
             => writes "-3.9230E+1"
          
          w.WriteReal(0.0003923009, 6, 1);
             => writes "  4E-4"

Method: `(W: Writer)' WriteLReal `(LREAL: LONGREAL; N, K: LONGINT)'
     This method provides the same facility as `WriteReal', except that
     it deals with `LONGREAL' values.

Method: `(W: Writer)' WriteRealEng `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a floating-point number with a minimum
     field width of N.

     If the value of K is greater than 0, that number of significant
     digits is included.  Otherwise, an implementation-defined number
     of significant digits is included.  The decimal point is not
     included if there are no significant digits in the fractional part.

     The number is scaled with one to three digits in the whole number
     part and with an exponent that is a multiple of three.  A sign is
     included only for negative values.

     *Example:*

          w.WriteRealEng(39.23009, 0, 1);
             => writes "40"
          w.WriteRealEng(39.23009, 5, 2);
             => writes "   39"
          w.WriteRealEng(39.23009, 10, 5);
             => writes "    39.230"
          
          w.WriteRealEng(-3923009, 13, 1);
             => writes "        -4E+6"
          w.WriteRealEng(-3923009, 7, 3);
             => writes " -3.92E+6"
          w.WriteRealEng(-3923009, 0, 6);
             => writes "-3.92301E+6"
          
          w.WriteRealEng(0.0003923009, 1, 1);
             => writes "400E-6"
          w.WriteRealEng(0.0003923009, 4, 2);
             => writes "  390E-6"
          w.WriteRealEng(0.0003923009, 16, 5);
             => writes "       392.30E-6"

Method: `(W: Writer)' WriteLRealEng `(LREAL: LONGREAL; N, K: LONGINT)'
     This method provides the same facility as `WriteRealEng', except
     that it deals with `LONGREAL' values.

Method: `(W: Writer)' WriteRealFix `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a fixed-point number with a minimum
     field width of N.

     The value is rounded to the given value of K relative to the
     decimal point.  The decimal point is suppressed if K is less than
     0.

     The number will have at least one digit in the whole number part.
     A sign is included only for negative values.

     *Example:*

          w.WriteRealFix(3923009, 0, -5);
             => writes "3920000"  (* rounded to the
                                  ten-thousands place *)
          w.WriteRealFix(3923009, 0, 4);
             => writes "3923009.0000"
          
          w.WriteRealFix(3923.5, 0, -1);
             => writes "3924" (* rounded to the "ones" place *)
          w.WriteRealFix(3923.5, 0, 0);
             => writes "3924." (* same as above,
                                  but writes a decimal point *)
          
          w.WriteRealFix(-39.23009, 10, 1);
             => writes "     -39.2"
          w.WriteRealFix(-39.23009, 20, 4);
             => writes "            -39.2301"
          
          w.WriteRealFix(0.0003923009, 5, 1);
             => writes "  0.0"
          w.WriteRealFix(0.0003923009, 11, 4);
             => writes "     0.0004"

Method: `(W: Writer)' WriteLRealFix `(LREAL: LONGREAL; N, K: LONGINT)'
     This method provides the same facility as `WriteRealFix', except
     that it deals with `LONGREAL' values.

Method: `(W: Writer)' WriteSet `(S: SET)'
     Writes the value of S as an Oberon-2 set constructor, including
     curly braces, commas, and range indicators ("`..'") where
     appropriate.

     *Example:*

          w.WriteSet({});
             => writes "{}"
          w.WriteSet({1,6,10});
             => writes "{1, 6, 10}"
          w.WriteSet({0, 1, 2, 3, 4, 5});
             => writes "{0..5}"
          w.WriteSet({0, 2, 3, 4, 8});
             => writes "{0, 2..4, 8}"
          w.WriteSet({0, 2..7, 8});
             => writes "{0, 2..8}"
          w.WriteSet({0, 2, 4, 6} + {1, 3, 5, 7});
             => writes "{0..7}"

Method: `(W: Writer)' WriteString `(S: ARRAY OF CHAR)'
     Writes a string value up to, but not including, the terminating
     `0X' character.  The behaviour of this method is undefined if S is
     an unterminated character array.

     *Please note:* `ReadString' and `WriteString' *are not* symmetric.
     That is, `WriteString' does not enclose the written string in
     quote marks; only the actual character values contained in S are
     written.

Method: `(W: Writer)' WriteLn
     Writes an end-of-line marker (i.e., a "newline").  The default
     value for a newly created writer is `CharClass.systemEol' (see
     `SetEol' above).


File: OOCref.info,  Node: Class Scanner (TextRider),  Next: Connecting TextRiders,  Prev: Class Writer (TextRider),  Up: TextRider

Class Scanner (TextRider)
.........................

   A "text scanner" is a special type of reader, which is used to parse
text for different kinds of tokens.  Integers, reals, strings,
identifiers, set constructors, the boolean tokens `TRUE' and `FALSE',
and other special symbols are all tokens recognized by this kind of
scanner.

   These tokens are scanned sequentially, converted to an appropriate
type, and then returned in one of the scanner's fields.  The scanner's
`type' field is then used to determine the type of token which has been
scanned.

   Along with some typical reader methods, such as `SetPos', the primary
method of a scanner is `Scan', which simply scans the next token based
on the scanner's current options setting.  A typical use of a scanner
might look similar the following program fragment:

   *Example:*

     VAR s: TextRider.Scanner;
         f: Files.File;
         res: Files.Result;
     
       f := Files.Old("Sample.txt", {Files.read}, res);
       s := TextRider.ConnectScanner(f);
     
       s.Scan;
       WHILE s.type # TextRider.error DO
          IF s.type = TextRider.string THEN
             ... (* Process string tokens *)
          ELSIF s.type = TextRider.ident THEN
             ... (* Process identifier tokens *)
          ELSIF s.type = TextRider.int THEN
             ... (* Process integer tokens *)
          ELSIF ...
             ... (* Process other token types *)
          END;
          s.Scan;
       END;
     
       Out.String("Total lines scanned=");
       Out.LongInt(s.lines, 0); Out.Ln;

 - Data type: String
     A string type of pre-defined length for use within a scanner.
     Note that because this type is of finite length, a scanner is
     limited in the length of string it can scan.

     *Please note:* `LEN()' can be used on a variable of type `String'
     to determine the maximum size that can be held by a scanner string.

 - Class: Scanner = POINTER TO ScannerDesc
     This class provides facilities for scanning sequences of
     characters from a channel and parsing those characters into
     various tokens.  The tokens a scanner can recognize are defined by
     the constants provided for its `type' field (*Note Summary of
     TextRider Constants::).

     Note that a scanner will not continue to read (via calls to
     `Scan') if it has scanned an invalid token or an error occurs;
     `ClearError' must be called explicitly before scanning can
     continue.  The difference is that `invalid' means that the token
     could not be interpreted; a sequence of characters was read, but
     could not be interpreted as a valid token.  An `error' occurs when
     there is a problem with the underlying `Reader'; so, `error' is
     used to determine when you have reached end-of-text.

    Field: base-: `Channel.Channel'
          This field refers to the channel the scanner is connected to.

    Field: lines-: `LONGINT'
          Total number of lines (i.e., end-of-line characters) that
          have been scanned.  This number is updated by `Scan'.

    Field: opt-: `SET'
          The current read options setting for the scanner.  See *Note
          Summary of TextRider Constants:: for possible option values.

    Field: pos-: `LONGINT'
          Starting position of the most recently scanned token.  Note
          that this is *not* the same as the value returned by the
          `Pos()' method.

          This value may be useful when an `invalid' token is scanned,
          as it will point to the start of the `invalid' token (whereas
          `Pos()' would be positioned *after* the invalid token).  You
          could, for example, reset the scanner options and re-position
          the scanner back at the invalid token to attempt a re-scan.

    Field: res-: `Msg.Msg'
          This field indicates the status of the last read operation
          (e.g., `Scan', `SetPos', etc.).

          If `res#done', use either `res.GetLText()' or `res.GetText()'
          to get a plain text error description corresponding to the
          error code.

    Field: type-: `INTEGER'
          The type of the token that has been most recently scanned.
          The constants `bool', `char', `error', `int', `invalid',
          `line', `ident', `real', `set', `string', `tab', and
          `undefined' are possible values for `type'.  See also the
          related output fields listed below.

     The following are the output fields within a scanner.  Before the
     first call to the `Scan' method, the values of these fields are
     undefined.  After each successive call to `Scan', `type' is set
     and the matching output field contains the value of the scanned
     token.  The value of output fields not corresponding to `type' are
     undefined.

    Field: bool-: `BOOLEAN'
          This field will contain a valid value only if the
          `interpretBools' option is set and one of the tokens `TRUE'
          or `FALSE' is scanned.

    Field: char-: `CHAR'
          Contains a value if `type' is `char', `line', or `tab'.

    Field: int-: `LONGINT'
          Contains a value if `type' is `int'.

          *Please note:* Valid integers are in either signed decimal or
          unsigned hexadecimal formats (hexadecimal tokens *must* be
          terminated with an "`H'" character).

    Field: real-: `LONGREAL'
          Contains a value if `type' is `real'.

    Field: set-: SET;
          Contains a value if `type' is `set'.

    Field: string-: String;
          Contains a value if `type' is `string' or `ident'.

   The following scanner methods are equivalent to the corresponding
reader methods described in *Note Class Reader (TextRider)::, so only
brief descriptions are given here.

     *Please note:* Normally when scanning text, a program will monitor
     a scanner's `type' field and check for `invalid' tokens and the
     occurance of `error'.  The `res.code' needs to be checked only to
     find out error details (and then, possibly, the `ClearError'
     method can be used to clear the error).

     *Example:*

          VAR s: TextRider.Scanner;
              f: Files.File;
              res: Files.Result;
              str: ARRAY 256 OF CHAR;
          
          f := Files.Old("Sample.txt", {Files.read}, res);
          s := TextRider.ConnectScanner(f);
          
          f.Close;
          s.Scan;
             => s.type = error
          s.res.GetText(str);
             => str = "File has been closed"

Method: `(S: Scanner)' Available `() : LONGINT'
     Returns the number of bytes available for the next scanning
     operation.

Method: `(S: Scanner)' ClearError
     Clears error conditions on the scanner S, re-enabling further
     operations on S.

Method: `(S: Scanner)' Pos `(): LONGINT'
     Returns the current reading position associated with the scanner S
     in channel `S.base'.  Note that the value returned by this method
     is different from the position indicated by the scanner's `pos'
     field.

Method: `(S: Scanner)' SetEol `(MARKER: ARRAY OF CHAR; MARKERLEN: INTEGER)'
     This method sets the end-of-line marker; it provides the same
     facility as `Reader.SetEol'.  A marker length `markerLen=-1'
     enables auto detection of the end-of-line convention used by the
     channel.

Method: `(S: Scanner)' SetOpts `(OPTS: SET)'
     This method is used to set the scanner options `S.opt'.  See *Note
     Summary of TextRider Constants:: for possible option values.

     *Example:*

          s.SetOpts({TextRider.returnCtrlChars,
                  TextRider.useSignedNumbers});
             => s.opt = {returnCtrlChars, useSignedNumbers}
          s.SetOpts(s.opt + {TextRider.interpretBools});
             => s.opt = {interpretBools, returnCtrlChars,
                  useSignedNumbers}
          s.SetOpts(TextRider.defScannerOptions);
             => scanner options set to default values.

Method: `(S: Scanner)' SetPos `(NEWPOS: LONGINT)'
     Sets the current scanning position to NEWPOS.

Method: `(S: Scanner)' Scan
     This method skips whitespace, and then scans for the next token as
     specified by the scanning options.  Based on the type of token
     scanned, `S.type' is set and the matching output field is assigned
     a value.

     If the end of the valid text is reached, `S.type' is set to
     `error'.  (Note that `error' is set when the last available valid
     token is read, not necessarily by a `readAfterEnd' condition.)

     Valid tokens are described as follows:

    `bool'
          If `interpretBools' is set as a scanner option, the text
          tokens `TRUE' or `FALSE' are read as `bool'.  (Otherwise,
          these tokens are read as type `ident'.)

    `char'
          Normally, any printable characters other than a letter or
          number and any non-printable control character.  However,
          scanner options will affect what a scanner interprets to be a
          `char':

             * If `interpretSets' is not set, elements of a set
               constructor, "`{'", "`}'", "`,'", are read as `char'
               (and the associated integer constants are read as
               separate tokens).

             * If `interpretStrings' is not set, quote characters are
               read as `char' (and string contents are then read as
               separate tokens).

             * If `useSignedNumbers' is not set, "`+'" and "`-'" are
               read as `char'.  (Otherwise, they are always considered
               part of a number.)

    `int'
          Any Oberon-2 integer constant.  (Note that hexadecimal
          numbers must be unsigned and be terminated with an "`H'".
          Also, lower-case letters, `a..f', are not valid hex digits.)

    `line'
          If `returnCtrlChars' is set, an end-of-line character is read
          as `S.type = line'.  Otherwise, it is counted as whitespace.

    `ident'
          Any Oberon-2 identifier.  (Note that "`_'" is not considered
          as part of an identifier, nor is a selector "`.'".)

    `real'
          Any Oberon-2 real number constant.

    `set'
          Any Oberon-2 set constructor.

    `string'
          Any Oberon-2 string constant.

    `tab'
          If `returnCtrlChars' is set, a tab character is read as
          `S.type = tab'.  Otherwise, it is counted as whitespace.


File: OOCref.info,  Node: Connecting TextRiders,  Next: Summary of TextRider Constants,  Prev: Class Scanner (TextRider),  Up: TextRider

Connecting TextRiders to Channels
.................................

   The following procedures are provided for creating instances of
`TextRider' objects and connecting them to a channel.  If the channel
being passed as an argument to any of these functions has a value of
`NIL', behavior is undefined.

   Also, for any of these functions, the returned rider is positioned
at the beginning of the channel for positionable channels and at the
current position for non-positionable channels.

 - Function: ConnectReader `(CH: Channel.Channel): Reader'
     This function creates a new reader and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new reader is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

 - Function: ConnectWriter `(CH: Channel.Channel): Writer'
     This function creates a new writer and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new writer is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

 - Function: ConnectScanner `(CH: Channel.Channel): Scanner'
     This function creates a new scanner and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new scanner is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

   *Example:*

     VAR
       r: TextRider.Reader;
       f: Files.File;
       res: Files.Result;
     
       f := Files.Old("test.dat", {Files.read}, res);
       IF (res # Files.done) THEN (* error processing *) END;
     
       r := TextRider.ConnectReader(f);
       IF (r = NIL) THEN (* error processing *) END;


File: OOCref.info,  Node: Summary of TextRider Constants,  Prev: Connecting TextRiders,  Up: TextRider

Summary of TextRider Constants
..............................

 - Constant: maxLengthEol
     The maximum number of characters allowed in `Reader.eol'.

   For other constant values that may be applicable when using module
`TextRider', see the specific channel implementation that you are
reading to or writing from, such as *Note Files::, *Note StdChannels::,
or *Note ProgramArgs::.

   The following constant applies to the `res' field, and may be
compared to it.  (i.e., `rider.res = done' or `rider.res # done'.)

 - Constant: done
     This indicates successful completion of the last operation.

   The following are possible values for `res.code':

 - Constant: invalidFormat
     Indicates that the text at the current reading (or scanning)
     position is not properly formatted as the requested type.

 - Constant: valueOutOfRange
     Indicates that a number, or potential set element, is in the
     proper format, but has a value that is out of range of the target
     type.

   The following are all possible values for a scanner's `type' field:

 - Constant: bool
     The scanner has read a valid boolean value.  This can only be set
     when the scanner's options include `interpretBools'.

 - Constant: char
     The scanner has read a valid character value.

 - Constant: error
     Indicates that an error has occured while scanning.  This could be
     an error condition resulting from one of the scanner's own
     operations (for example, an attempt to `Scan' when the scanner has
     reached the end of available text), or a result of a lower level
     error (say, an error occured in the underlying channel).

 - Constant: ident
     The scanner has read a valid (Oberon-2) identifier.

 - Constant: int
     The scanner has read a valid integer value.

 - Constant: invalid
     The scanner has read an invalid value.  Note that when `type =
     invalid', the contents of all of the scanner's output fields are
     undefined.

 - Constant: line
     The scanner has read a valid end-of-line character.  This can only
     be set when the scanner's options include `returnCtrlChars'.

 - Constant: real
     The scanner has read a valid real number value.

 - Constant: set
     The scanner has read a valid set constructor value.  This can only
     be set when the scanner's options include `interpretSets'.

 - Constant: string
     The scanner has read a valid (Oberon-2) string value.  This can
     only be set when the scanner's options include `interpretStrings'.

 - Constant: tab
     The scanner has read a valid tab character.  This can only be set
     when the scanner's options include `returnCtrlChars'.

 - Constant: undefined
     This is the initial value of `Scanner.type' after `ConnectScanner'
     or `ClearError' (before any calls to `Scan').

   The following is a possible writer option (i.e., a valid setting for
the writer's `opt' field):

 - Constant: noBuffering
     When this option is set for a writer, output is not buffered.
     This allows, for example, for interactive output prompts to appear
     as soon as they are written.

   The following is a possible reader or scanner option (i.e., a valid
setting for the `opt' field):

 - Constant: returnCtrlChars
     When this option is set, end-of-line and tab characters are *not*
     counted as whitespace.

   Scanners also permit the following additional options:

 - Constant: interpretBools
     When this option is set, the text tokens `TRUE' or `FALSE' are
     read as boolean values (i.e., `scanner.type = bool').  Otherwise,
     these tokens are read as identifiers (i.e., `scanner.type =
     ident'.)

 - Constant: interpretSets
     When set, text in the form a set constructor (with "`{'", "`}'",
     "`,'", and associated integer constants) are read as `SET' values.
     Otherwise, these are read as separate tokens.

 - Constant: interpretStrings
     When set, quoted character sequences are read as string values.
     Otherwise, quote characters and string contents are read as
     separate tokens.

 - Constant: useSignedNumbers
     When set, "`+'" and "`-'" characters are always considered part of
     a number.  Otherwise, they are read as separate characters.

 - Constant: defReaderOptions
     The default reader options setting, which is equivalent to having
     no options set (i.e., `{}').

 - Constant: defWriterOptions
     The default writer options setting, which is equivalent to having
     no options set (i.e., `{}').

 - Constant: defScannerOptions
     The default scanner options setting, which is equivalent to
     setting the options `interpretBools', `interpretSets',
     `interpretStrings', and
     `useSignedNumbers'.


File: OOCref.info,  Node: UnicodeRider,  Prev: TextRider,  Up: Text Mappers

Module UnicodeRider
-------------------

   Module `UnicodeRider' provides concrete classes derived from the
abstract base classes of module `LongRider'.  `UnicodeRider' is used
for reading and writing data as (long) character type `LONGCHAR' (i.e.,
interpreting byte streams as Unicode characters).  The following
sections describe only `UnicodeRider' specific facilities; see *Note
TextRider:: for examples of usage and descriptions of facilities
inherited from *Note Rider::.

* Menu:

* Class Reader (UnicodeRider):: Class for reading unicode text from channels.
* Class Writer (UnicodeRider):: Class for writing unicode text to channels.
* Class Scanner (UnicodeRider)::Class for scanning unicode text from
                                  channels.
* Connecting UnicodeRiders::    Procedures to connect (unicode) readers,
                                  writers, and scanners to channels.
* Summary of UnicodeRider Constants:: Summarized list of constants in module
                                  UnicodeRider.


File: OOCref.info,  Node: Class Reader (UnicodeRider),  Next: Class Writer (UnicodeRider),  Up: UnicodeRider

Class Reader (UnicodeRider)
...........................

 - Class: Reader = POINTER TO ReaderDesc
     This is the concrete subclass of `LongRider.Reader' that provides
     facilities for reading various kinds of unicode text.

     Note that, in `UnicodeRider.Reader', `ReadChar' actually reads a
     `LONGCHAR' value (2 bytes) from the channel and then attempts to
     map it to a `CHAR' value (ISO-Latin-1).  If the value cannot be
     mapped, a `valueOutOfRange' error occurs.  Consequently for
     `UnicodeRider', `ReadLine', `ReadIdentifier', and `ReadString'
     produce the same error in similar situations.

     Also note that a `valueOutOfRange' error occurs for methods reading
     into an `ARRAY OF LONGCHAR' (i.e., `ReadLLine', `ReadLIdentifier',
     and `ReadLString') if the (long) character array is not large
     enough to hold the entire input.

   `UnicodeRider.Reader' adds the following methods:

Method: `(R: Reader)' ReadLChar `(VAR CH: LONGCHAR)'
     Reads in a single (`LONGCHAR') character value and places it in CH.

Method: `(R: Reader)' ReadLIdentifier `(VAR S: ARRAY OF LONGCHAR)'
     Reads an Oberon-2 style identifier into S.  An "identifier" is a
     sequence of letters and digits, which must begin with a letter.

     Sequences not beginning with a letter produce an `invalidFormat'
     error.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.

Method: `(R: Reader)' ReadLLine `(VAR S: ARRAY OF LONGCHAR)'
     Reads a sequence of (`LONGCHAR') characters into S; reading
     continues until an end-of-line character is encountered, the array
     S is full, or R reaches the end of the channel.  The end-of-line
     character is discarded and S is always terminated with `0X'.

     If R is already positioned at an end-of-line character, S returns
     as an empty string.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs; S returns with the sequence of
     characters that have been read so far (terminated by `0X').

     If R has already reached the end of the channel (i.e., there are no
     more characters left to read), a `readAfterEnd' error occurs and S
     returns as an empty string.

Method: `(R: Reader)' ReadLString `(VAR S: ARRAY OF CHAR)'
     Reads in a sequence of (`LONGCHAR') characters enclosed in single
     (`'') or double (`"') quote marks.  The opening quote must be the
     same as the closing quote and must not occur within the string.

     Characters will be read until the terminating quote mark is
     encountered, an invalid character is read (end-of-line is always
     considered invalid), there are no more characters available in the
     channel, or the string S is full.  S is always terminated with
     `0X'.

     Unquoted strings produce an `invalidFormat' error.  Strings with no
     terminating quote mark also result in an `invalidFormat' error.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.


File: OOCref.info,  Node: Class Writer (UnicodeRider),  Next: Class Scanner (UnicodeRider),  Prev: Class Reader (UnicodeRider),  Up: UnicodeRider

Class Writer (UnicodeRider)
...........................

 - Class: Writer = POINTER TO WriterDesc
     This is the concrete subclass of `LongRider.Writer' that provides
     facilities for writing various kinds of unicode text.

   For `UnicodeRider.Writer', note that `WriteChar' actually writes 2
bytes at a time to the channel (i.e., `CHAR' values are actually
written as Unicode values).  `ReadLine', `ReadIdentifier', and
`ReadString' behave similarly for `LongRider'.

   `UnicodeRider.Writer' adds the following methods:

Method: `(W: Writer)' WriteLChar `(CH: LONGCHAR)'
     Writes a single (`LONGCHAR') character value CH.

Method: `(W: Writer)' WriteLString `(S: ARRAY OF LONGCHAR)'
     Writes a long string value up to, but not including, the
     terminating `0X' character.  The behaviour of this method is
     undefined if S is an unterminated (`LONGCHAR') character array.

     *Please note:* `ReadLString' and `WriteLString' *are not*
     symmetric.  That is, `WriteLString' does not enclose the written
     string in quote marks; only the actual (`LONGCHAR') character
     values contained in S are written.


File: OOCref.info,  Node: Class Scanner (UnicodeRider),  Next: Connecting UnicodeRiders,  Prev: Class Writer (UnicodeRider),  Up: UnicodeRider

Class Scanner (UnicodeRider)
............................

 - Class: Scanner = POINTER TO ScannerDesc
     This is the concrete subclass of `LongRider.Scanner' that provides
     facilities for scanning sequences of (long) characters from a
     channel and parsing those characters into various tokens.  The
     tokens a scanner can recognize are defined by the constants
     provided for its `type' field (*Note Summary of UnicodeRider
     Constants::).

      - Data type: LongString
          A (long) string type of pre-defined length for use within a
          scanner.  Note that because this type is of finite length, a
          scanner is limited in the length of string it can scan.

          *Please note:* `LEN()' can be used on a variable of type
          `LongString' to determine the maximum size that can be held
          by a scanner string.

    Field: type-: `INTEGER'
          This is an inherited field, however, it now has the
          additional possible values: `lchar', `lident', `lline',
          `lstring', `ltab'.

    Field: lchar-: `LONGCHAR'
          Contains a value if `type' is `lchar', `lline', or `ltab'.

    Field: lstring-: LongString;
          Contains a value if `type' is `lstring' or `lident'.

   *Please note:* After a call to `Scan', the `type' field of
`UnicodeRider.Scanner' is never expected to contain any of the
following values: `char', `ident', `line', `string', `tab'.  But
rather, the "long" versions of these type values are set as appropriate.


File: OOCref.info,  Node: Connecting UnicodeRiders,  Next: Summary of UnicodeRider Constants,  Prev: Class Scanner (UnicodeRider),  Up: UnicodeRider

Connecting UnicodeRiders to Channels
....................................

   The following procedures are provided for creating instances of
`UnicodeRider' objects and connecting them to a channel.  If the
channel being passed as an argument to any of these functions has a
value of `NIL', behavior is undefined.

   Also, for any of these functions, the returned rider is positioned
at the beginning of the channel for positionable channels and at the
current position for non-positionable channels.

 - Function: ConnectReader `(CH: Channel.Channel): Reader'
     This function creates a new reader and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new reader is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

 - Function: ConnectWriter `(CH: Channel.Channel): Writer'
     This function creates a new writer and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new writer is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

 - Function: ConnectScanner `(CH: Channel.Channel): Scanner'
     This function creates a new scanner and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new scanner is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.


File: OOCref.info,  Node: Summary of UnicodeRider Constants,  Prev: Connecting UnicodeRiders,  Up: UnicodeRider

Summary of UnicodeRider Constants
.................................

 - Constant: maxLengthEol
     The maximum number of characters allowed in `Reader.eol'.

   For other constant values that may be applicable when using module
`UnicodeRider', see the specific channel implementation that you are
reading to or writing from, such as *Note Files::, *Note StdChannels::,
or *Note ProgramArgs::.

   The following constant applies to the `res' field, and may be
compared to it.  (i.e., `rider.res = done' or `rider.res # done'.)

 - Constant: done
     This indicates successful completion of the last operation.

   The following are possible values for `res.code':

 - Constant: invalidFormat
     Indicates that the text at the current reading (or scanning)
     position is not properly formatted as the requested type.

 - Constant: valueOutOfRange
     Indicates that a number, or potential set element, is in the
     proper format, but has a value that is out of range of the target
     type.

   The following are all possible values for a scanner's `type' field:

 - Constant: bool
     The scanner has read a valid boolean value.  This can only be set
     when the scanner's options include `interpretBools'.

 - Constant: char
     The scanner has read a valid character value.

     (For `UnicodeRider', `type' is never expected to contain this
     value.  But rather, the "long" version is set when appropriate.)

 - Constant: lchar
     The scanner has read a valid (long) character value.

 - Constant: error
     Indicates that an error has occured while scanning.  This could be
     an error condition resulting from one of the scanner's own
     operations (for example, an attempt to `Scan' when the scanner has
     reached the end of available text), or a result of a lower level
     error (say, an error occured in the underlying channel).

 - Constant: ident
     The scanner has read a valid (Oberon-2) identifier.

     (For `UnicodeRider', `type' is never expected to contain this
     value.  But rather, the "long" version is set when appropriate.)

 - Constant: lident
     The scanner has read a valid (Oberon-2) identifier (as a
     `LongString').

 - Constant: int
     The scanner has read a valid integer value.

 - Constant: invalid
     The scanner has read an invalid value.  Note that when `type =
     invalid', the contents of all of the scanner's output fields are
     undefined.

 - Constant: line
     The scanner has read a valid end-of-line character.  This can only
     be set when the scanner's options include `returnCtrlChars'.

     (For `UnicodeRider', `type' is never expected to contain this
     value.  But rather, the "long" version is set when appropriate.)

 - Constant: lline
     The scanner has read a valid (long) end-of-line character.  This
     can only be set when the scanner's options include
     `returnCtrlChars'.

 - Constant: real
     The scanner has read a valid real number value.

 - Constant: set
     The scanner has read a valid set constructor value.  This can only
     be set when the scanner's options include `interpretSets'.

 - Constant: string
     The scanner has read a valid (Oberon-2) string value.  This can
     only be set when the scanner's options include `interpretStrings'.

     (For `UnicodeRider', `type' is never expected to contain this
     value.  But rather, the "long" version is set when appropriate.)

 - Constant: lstring
     The scanner has read a valid (Oberon-2) (long) string value.  This
     can only be set when the scanner's options include
     `interpretStrings'.

 - Constant: tab
     The scanner has read a valid (long) tab character.  This can only
     be set when the scanner's options include `returnCtrlChars'.

     (For `UnicodeRider', `type' is never expected to contain this
     value.  But rather, the "long" version is set when appropriate.)

 - Constant: ltab
     The scanner has read a valid tab character.  This can only be set
     when the scanner's options include `returnCtrlChars'.

 - Constant: undefined
     This is the initial value of `Scanner.type' after `ConnectScanner'
     or `ClearError' (before any calls to `Scan').

   The following is a possible writer option (i.e., a valid setting for
the writer's `opt' field):

 - Constant: noBuffering
     When this option is set for a writer, output is not buffered.
     This allows, for example, for interactive output prompts to appear
     as soon as they are written.

   The following is a possible reader or scanner option (i.e., a valid
setting for the `opt' field):

 - Constant: returnCtrlChars
     When this option is set, end-of-line and tab characters are *not*
     counted as whitespace.

   Scanners also permit the following additional options:

 - Constant: interpretBools
     When this option is set, the text tokens `TRUE' or `FALSE' are
     read as boolean values (i.e., `scanner.type = bool').  Otherwise,
     these tokens are read as identifiers (i.e., `scanner.type =
     ident'.)

 - Constant: interpretSets
     When set, text in the form a set constructor (with "`{'", "`}'",
     "`,'", and associated integer constants) are read as `SET' values.
     Otherwise, these are read as separate tokens.

 - Constant: interpretStrings
     When set, quoted character sequences are read as string values.
     Otherwise, quote characters and string contents are read as
     separate tokens.

 - Constant: useSignedNumbers
     When set, "`+'" and "`-'" characters are always considered part of
     a number.  Otherwise, they are read as separate characters.

 - Constant: defReaderOptions
     The default reader options setting, which is equivalent to having
     no options set (i.e., `{}').

 - Constant: defWriterOptions
     The default writer options setting, which is equivalent to having
     no options set (i.e., `{}').

 - Constant: defScannerOptions
     The default scanner options setting, which is equivalent to
     setting the options `interpretBools', `interpretSets',
     `interpretStrings', and
     `useSignedNumbers'.


File: OOCref.info,  Node: BinaryRider,  Prev: Text Mappers,  Up: Standard Mappers

Module BinaryRider
------------------

   Module BinaryRider provides facilities for reading and writing
"binary data".  Binary data are simple sequences of byte values that
may be interpreted in any number of ways.  This corresponds closely to
the way information is stored within a running program.  Values are
stored as a fixed number of bytes rather than as a delimited sequence
of characters.  For example, if `SIZE(INTEGER) = 2', then an `INTEGER'
value is always stored as 2 bytes.  If `SIZE(LONGINT) = 4', then a
`LONGINT' is stored as 4 bytes.

   The following program fragment gives an example of how you could
read the entire contents of a file and echo each character to the
screen (note that no error checking is done):

     VAR r: BinaryRider.Reader;
         f: Files.File;
         ch: CHAR;
         res: Files.Result;
     
       f := Files.Old("Sample.txt", {Files.read}, res);
       r := BinaryRider.ConnectReader(f);
     
       r.ReadChar(ch);
       WHILE r.res=Files.done DO
          Out.Char(ch);
          r.ReadChar(ch);
       END;

     *Please note*: Different kinds of computers use different
     conventions for the ordering of bytes within a word.  Some
     computers put the most significant byte within a word first (this
     is called "big-endian" order), and others put it last
     ("little-endian" order).  A small number of systems use different
     byte order schemes; they aren't supported by this module (yet).
     Operations provided by BinaryRider default to the little-endian
     byte order.  However, byte order can be specified using the
     `SetByteOrder' methods provided by classes `Reader' and `Writer'.

     Thus, programs can be written that produce files that are portable
     to machines with different byte orderings.  It should be noted,
     however, that file I/O using the native byte order provides better
     speed efficiency.

* Menu:

* Class Reader (BinaryRider)::  Class for reading binary data from channels.
* Class Writer (BinaryRider)::  Class for writing binary data to channels.
* Connecting BinaryRiders::     Procedures to connect binary readers and
                                 writers to channels.
* Summary of BinaryRider Constants:: Summarized list of constants in module
                                 BinaryRider.

