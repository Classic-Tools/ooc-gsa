This is Info file OOCref.info, produced by Makeinfo version 1.68 from
the input file OOCref.texinfo.

   This file documents the Optimizing Oberon-2 Compiler (OOC) and its
library.

   This is Edition 0.10 DRAFT, last updated 29 February 2000, of `The
OOC Library Reference Manual', for Version 1.5.1 or later of oo2c.

   Copyright (C) 1997-2000 Eric Nikitin Part II Copyright (C) 1998-2000
Michael van Acken

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: OOCref.info,  Node: Class Reader (BinaryRider),  Next: Class Writer (BinaryRider),  Up: BinaryRider

Class Reader (BinaryRider)
..........................

 - Class: Reader = POINTER TO ReaderDesc
     This class provides facilities for reading various types of data
     in binary format.  Note that this type does not inherit properties
     from any basic reader type; rather it uses the basic reader type
     associated with the channel it is attached to.

          *Please note*: Many of the methods for `BinaryRider.Reader'
          perform typical `Reader' operations.  Rather than duplicate
          descriptions of those methods here, a reference to the
          abstract reader type is provided instead.

    Field: res-: `Msg.Msg'
          This field indicates the status of the last read operation
          (e.g., `ReadLine', `ReadInt', `SetPos', etc.).

          Error codes (for `res.code') are highly dependent on the
          channel being read, and therefore on the basic riders
          provided by that channel, so you must look at the result
          codes for a particular channel's reader type (e.g.,
          `Files.Reader' error codes).  See the various channel types
          for details of these error codes (i.e., *Note Files::, *Note
          StdChannels::, or *Note ProgramArgs::).

          If `res#done', use either `res.GetLText()' or `res.GetText()'
          to get a plain text error description corresponding to the
          error code.

    Field: byteOrder-: `SHORTINT'
          The current endian (byte order) setting for the reader.

    Field: base-: `Channel.Channel'
          This field refers to the channel the reader is connected to.

   The following methods are all fully described in the section on
abstract readers (*note Abstract Class Reader::.), so only brief
descriptions are given here.

Method: `(R: Reader)' Available `() : LONGINT'
     Returns the number of bytes available for the next reading
     operation.

Method: `(R: Reader)' ClearError
     Clears error conditions on the reader R, re-enabling further read
     operations.

Method: `(R: Reader)' Pos `() : LONGINT'
     Returns the current reading position associated with the reader R
     in channel `R.base'.

Method: `(R: Reader)' SetByteOrder `(ORDER: SHORTINT)'
     Sets `byteOrder' in reader R to ORDER.  This affects the
     interpretation of byte values for applicable read operations.

     *Pre-condition*: ORDER is one of `nativeEndian', `littleEndian',
     or `bigEndian'.

     *Example:*

          VAR rBig, rLittle, r: BinaryRider.Reader;
              f: Files.File;
          
          f := Files.Old("test.dat", {Files.read}, res);
          
          r := BinaryRider.ConnectReader(f);
             => r reads from f using the default byte order
                  (i.e., little endian)
          
          rBig := BinaryRider.ConnectReader(f);
          rBig.SetByteOrder(BinaryRider.bigEndian);
             => rBig reads from f using big endian byte order
          
          rLittle := BinaryRider.ConnectReader(f);
          rLittle.SetByteOrder(BinaryRider.littleEndian);
             => rLittle reads from f using little endian byte order

Method: `(R: Reader)' SetPos `(NEWPOS: LONGINT)'
     Sets the reading position to NEWPOS.

   The following methods read a value of the given type from the current
position of the Reader.  If the value is invalid for its type,
`Reader.res.code' is set to `invalidFormat'.

   Otherwise, if there aren't enough bytes to satisfy the request,
`Reader.res.code' is set to `readAfterEnd'.

Method: `(R: Reader)' ReadBool `(VAR BOOL: BOOLEAN)'
     Reads in a single byte and interprets it as a `BOOLEAN' value.
     Zero values are read as `FALSE' and non-zero values are read as
     `TRUE'.

     *Example:*

          VAR bool: BOOLEAN;
          
          r.ReadBool(bool);
             => if byte read = 0, then bool = FALSE;
                  otherwise, bool = TRUE

Method: `(R: Reader)' ReadBytes `(VAR X: ARRAY OF SYSTEM.BYTE;  START, N: LONGINT)'
     Read N bytes from the channel `R.base' according to the native
     machine byte order.  That is, `ReadBytes' is not affected by calls
     to `SetByteOrder'.  Thus this method is equivalent to any basic
     rider `Reader.ReadBytes' method (*note Abstract Class Reader::.)

     *Example:*

          VAR byteArr: ARRAY 256 OF CHAR;
          
          r.ReadBytes(byteArr, 0, 16);
             => reads the next 16 bytes from r.base
                  into byteArr[0..15]
          
          r.ReadBytes(byteArr, 16, 100);
             => reads the next 100 bytes from r.base
                  into byteArr[16..115]

Method: `(R: Reader)' ReadChar `(VAR CH: CHAR)'
     Reads in a single character value and places it in CH.

     *Please note*: OOC assumes that `SIZE(SYSTEM.BYTE) = SIZE(CHAR)'.

     *Example:*

          VAR ch: CHAR;
          
          r.ReadChar(ch);
             => reads one byte and assigns it to ch

Method: `(R: Reader)' ReadLChar `(VAR CH: LONGCHAR)'
     Reads in a single (long) character value and places it in CH.
     `SIZE(LONGCHAR)' bytes are read and interpreted based on the
     current byte order setting for reader R (see `SetByteOrder').

Method: `(R: Reader)' ReadInt `(VAR INT: INTEGER)'
     Reads in an `INTEGER' value.  `SIZE(INTEGER)' bytes are read and
     interpreted based on the current byte order setting for reader R
     (see `SetByteOrder').

Method: `(R: Reader)' ReadLInt `(VAR LINT: LONGINT)'
     Reads in a `LONGINT' value.  `SIZE(LONGINT)' bytes are read and
     interpreted based on the current byte order setting for reader R.

Method: `(R: Reader)' ReadLReal `(VAR LREAL: LONGREAL)'
     Reads in a `LONGREAL' value.  `SIZE(LONGREAL)' bytes are read and
     interpreted based on the current byte order setting for reader R.

Method: `(R: Reader)' ReadNum `(VAR NUM: LONGINT)'
     Reads an integer value in a compressed and portable format.  This
     format is the same no matter what the `byteOrder' setting.
     Therefore, `ReadNum' is not affected by calls to `SetByteOrder'.

Method: `(R: Reader)' ReadReal `(VAR REAL: REAL)'
     Reads in a `REAL' value.  `SIZE(REAL)' bytes are read and
     interpreted based on the current byte order setting for reader R.

Method: `(R: Reader)' ReadSet `(VAR S: SET)'
     Reads in a `SET' value.  `SIZE(SET)' bytes are read and
     interpreted based on the current byte order setting for reader R.

Method: `(R: Reader)' ReadSInt `(VAR SINT: SHORTINT)'
     Reads in a `SHORTINT' value.

     *Please note*: OOC assumes that `SIZE(SYSTEM.BYTE) =
     SIZE(SHORTINT)' so that the current byte order setting for reader R
     (see `SetByteOrder') does not matter for calls to `ReadSInt'.

Method: `(R: Reader)' ReadString `(VAR S: ARRAY OF CHAR)'
     Reads in a sequence of characters until either the string
     terminator `0X' is encountered, there are no more characters
     available in the channel, or the string S is full.  S is always
     terminated with `0X'.

     *Example:*

          VAR str: ARRAY 256 OF CHAR;
          
          r.ReadString(str);
             => reads up to 256 characters, stops when encounters 0X

Method: `(R: Reader)' ReadLString `(VAR S: ARRAY OF LONGCHAR)'
     Reads in a sequence of (long) characters until either the string
     terminator `0X' is encountered, there are no more characters
     available in the channel, or the string S is full.  S is always
     terminated with `0X'.  For each character, `SIZE(LONGCHAR)' bytes
     are read and interpreted based on the current byte order setting
     for reader R (see `SetByteOrder').


File: OOCref.info,  Node: Class Writer (BinaryRider),  Next: Connecting BinaryRiders,  Prev: Class Reader (BinaryRider),  Up: BinaryRider

Class Writer (BinaryRider)
..........................

 - Class: Writer = POINTER TO WriterDesc
     This class provides facilities for writing various types of data
     in binary format.  Note that this type does not inherit properties
     from any basic writer type; rather it uses the basic writer type
     associated with the channel it is attached to.

          *Please note*: Many of the methods for `BinaryRider.Writer'
          perform typical `Writer' operations.  Rather than duplicate
          descriptions of those methods here, a reference to the
          abstract writer type is provided instead.

    Field: res-: `Msg.Msg'
          This field indicates the status of the last write operation
          (e.g., `WriteBytes', `WriteInt', `SetPos', etc.).

          Error codes are highly dependent on the channel being written
          to (and therefore on the basic riders provided for that
          channel), so you must look at the result codes for the basic
          writer that is associated with that particular channel (e.g.,
          `Files.Writer' error codes).  See the various channel types
          for details of these error codes (i.e., *Note Files::, *Note
          StdChannels::, or *Note ProgramArgs::).

          If `res#done', use either `res.GetLText()' or `res.GetText()'
          to get a plain text error description corresponding to the
          error code.

    Field: base-: `Channel.Channel'
          This field refers to the channel the writer is connected to.

    Field: byteOrder-: `SHORTINT'
          The current endian (byte order) setting for the writer.

   The following methods are all fully described in the section on
abstract writers (*note Abstract Class Writer::.), so only brief
descriptions are given here.

Method: `(W: Writer)' ClearError
     Clears error conditions on the writer W, re-enabling further write
     operations.

Method: `(W: Writer)' Pos `() : LONGINT'
     Returns the current writing position associated with the writer
     `w' in channel `W.base'.

Method: `(W: Writer)' SetPos `(NEWPOS: LONGINT)'
     Sets the writing position to NEWPOS.

   The following writer methods are used to write values to the
underlying channel.  In some situations, it is possible for only part
of the value to be written.

Method: `(W: Writer)' WriteBytes `(VAR X: ARRAY OF SYSTEM.BYTE;  START, N: LONGINT)'
     Write N bytes to the channel `W.base' according to the native
     machine byte order (i.e., `WriteBytes' is not affected by calls to
     `SetByteOrder').  Thus this method is equivalent to any basic rider
     `Writer.WriteBytes' method (*note Abstract Class Writer::.)

     *Example:*

          VAR byteArr: ARRAY 256 OF CHAR;
          
          w.WriteBytes(byteArr, 0, 16);
             => writes the values of byteArr[0..15]
                  to the current writing position of w
          
          w.WriteBytes(byteArr, 16, 100);
             => writes the values of byteArr[16..115]
                  to the current writing position of w

Method: `(W: Writer)' WriteBool `(BOOL: BOOLEAN)'
     Writes a `BOOLEAN' value as a single byte.  `FALSE' is written as
     `0' and `TRUE' is written as 1.

     *Example:*

          w.WriteBool(TRUE);
             => writes one byte = 01H
          
          w.WriteBool(FALSE);
             => writes one byte = 00H

Method: `(W: Writer)' WriteChar `(CH: CHAR)'
     Writes the character value CH as a single byte.

     *Please note*: OOC assumes that `SIZE(SYSTEM.BYTE) = SIZE(CHAR)'.

     *Example:*

          VAR ch: CHAR:
          
          w.WriteChar("A");
             => writes one byte = "A"
          
          ch := 41X;
          w.WriteChar(ch);
             => writes one byte = 41X (i.e., "A" in ASCII)

Method: `(W: Writer)' WriteLChar `(CH: LONGCHAR)'
     Writes the (long) character value CH as `SIZE(LONGCHAR)' bytes
     based on the current byte order setting for writer W (see
     `SetByteOrder').

Method: `(W: Writer)' WriteString `(S: ARRAY OF CHAR)'
     Writes the string value of S (recall that a string is a character
     array containing `0X' as an embedded terminator).  The terminating
     `0X' is also written.

     *Example:*

          VAR str: ARRAY 256 OF CHAR;
          
          w.WriteString("abcdefg");
             => writes a total of 8 characters including 0X
          
          str := "hijkl";
          w.WriteString(str);
             => writes a total of 6 characters including 0X

Method: `(W: Writer)' WriteLString `(S: ARRAY OF LONGCHAR)'
     Writes the string value of S including the terminating `0X'
     character.  Each character is written as `SIZE(LONGCHAR)' bytes
     based on the current byte order setting for writer W (see
     `SetByteOrder').

Method: `(W: Writer)' WriteSInt `(SINT: SHORTINT)'
     Writes a `SHORTINT' value.

     *Please note*: OOC assumes that `SIZE(SYSTEM.BYTE) =
     SIZE(SHORTINT)' so that the current byte order setting for writer W
     (see `SetByteOrder') does not matter for calls to `WriteSInt'.

Method: `(W: Writer)' WriteInt `(INT: INTEGER)'
     Writes an `INTEGER' value.  `SIZE(INTEGER)' bytes are written
     based on the current byte order setting for writer W (see
     `SetByteOrder').

Method: `(W: Writer)' WriteLInt `(LINT: LONGINT)'
     Writes a `LONGINT' value.  `SIZE(LONGINT)' bytes are written based
     on the current byte order setting for writer W.

Method: `(W: Writer)' WriteNum `(LINT: LONGINT)'
     Write an integer value in a compressed and portable format.  This
     format is the same no matter what the `byteOrder' setting.
     Therefore, `WriteNum' is not affected by calls to `SetByteOrder'.

Method: `(W: Writer)' WriteReal `(REAL: REAL)'
     Writes a `REAL' value.  `SIZE(REAL)' bytes are written based on
     the current byte order setting for writer W.

Method: `(VAR W: Writer)' WriteLReal `(VAR LREAL: LONGREAL)'
     Writes a `LONGREAL' value.  `SIZE(LONGREAL)' bytes are written
     based on the current byte order setting for writer W.

Method: `(VAR W: Writer)' WriteSet `(VAR S: SET)'
     Writes a `SET' value.  `SIZE(SET)' bytes are written based on the
     current byte order setting for writer W.

Method: `(VAR W: Writer)' SetByteOrder `(VAR ORDER: SHORTINT)'
     Sets `byteOrder' in writer W to ORDER.  This affects the
     interpretation of byte values for applicable write operations.

     *Pre-condition*: ORDER is one of `nativeEndian', `littleEndian',
     or `bigEndian'.

     *Example:*

          VAR wBig, wLittle, w: BinaryRider.Writer;
              f: Files.File;
          
          f := Files.Old("test.dat", {Files.write}, res);
          
          w := BinaryRider.ConnectWriter(f);
             => w writes to f using native byte order
          
          wBig := BinaryRider.ConnectWriter(f);
          wBig.SetByteOrder(BinaryRider.bigEndian);
             => wBig writes to f using big endian byte order
          
          wLittle := BinaryRider.ConnectWriter(f);
          wLittle.SetByteOrder(BinaryRider.littleEndian);
             => wLittle writes to f using little endian byte order


File: OOCref.info,  Node: Connecting BinaryRiders,  Next: Summary of BinaryRider Constants,  Prev: Class Writer (BinaryRider),  Up: BinaryRider

Connecting BinaryRiders to Channels
...................................

   Functions are provided by module BinaryRider to connect readers and
writers to open channels.  If the channel being passed as an argument
to either of these functions has a value of `NIL', behavior is
undefined.

   Also, for either of these functions, the returned rider is
positioned at the beginning of the channel for positionable channels
and at the current position for non-positionable channels.

 - Function: ConnectReader `(VAR CH: Channel.Channel): Reader'
     This function creates a new reader and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new reader is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

 - Function: ConnectWriter `(VAR CH: Channel.Channel): Writer'
     This function creates a new writer and attaches it to the channel
     CH.  `CH.res' is set to `done' on success and the new writer is
     returned.  Otherwise, it returns `NIL' and `CH.res.code' is set to
     indicate the error cause.

   *Example:*

     VAR
       f: Files.File;
       r: BinaryRider.Reader;
       res: Files.Result;
     
       f := Files.Old("test.dat", {Files.read, Files.write}, res);
       IF (res # Files.done) THEN (* error processing *) END;
     
       r := BinaryRider.ConnectReader(f);
       IF (r = NIL) THEN (* error processing *) END;


File: OOCref.info,  Node: Summary of BinaryRider Constants,  Prev: Connecting BinaryRiders,  Up: BinaryRider

Summary of BinaryRider Constants
................................

   For other constant values that may be applicable when using module
`BinaryRider', see the specific channel implementation that you are
reading to or writing from.

   The following constant applies to the `res' field, and may be
compared to it.  (i.e., `rider.res = done' or `rider.res # done'.)

 - Constant: done
     This indicates successful completion of the last operation.

   The following are possible values for `res.code':

 - Constant: invalidFormat
     Indicates that the data at the current reading position is not
     properly formatted as the requested type.

 - Constant: readAfterEnd
     A read operation has tried to access a byte beyond the end of the
     channel.  This means that there weren't enough bytes available or
     the read operation started at (or after) the end.

   The following are possible endian (byte order) settings:

 - Constant: nativeEndian
     Use the host machine's byte order.

 - Constant: littleEndian
     Read/write least significant byte first.

 - Constant: bigEndian
     Read/write most significant byte first.


File: OOCref.info,  Node: Standard I/O,  Prev: Standard Mappers,  Up: I/O Subsystem

Standard I/O
============

   Modules `In', `Out', and `Err' provide simple interfaces to the
standard channels (*note StdChannels::.) These modules can be used to
read from predefined input (typically the keyboard) and write to
predefined output (typically the computer screen) locations.

   Historically, the various Oberon systems/ compilers have furnished
modules called `In' and `Out', which were intended primarily as aids for
learning the Oberon(-2) programming language.  These modules were often
over-simplified to such a degree that they were of limited use beyond
the initial learning stage.  The intention was that, after learning the
language, a programmer would learn other, more sophisticated methods for
I/O.

   Although the modules `In', `Out', and `Err' in the OOC library are
simple enough to be used by novices, they are not nearly as limited as
the corresponding modules from the original Oberon system.  Hence, they
are still useful to programmers well beyond the beginning stages.

   These modules give simplified facilities similar to module TextRider
applied to the standard channels; they allow reading and writing of
data as text.  If these prove to be insufficient for your needs, then
modules TextRider or BinaryRider may be used instead (*note Standard
Mappers::.)

* Menu:

* In::                          Simple interface to standard input.
* Out::                         Simple interface to standard output.
* Err::                         Simple interface to standard error channel.


File: OOCref.info,  Node: In,  Next: Out,  Up: Standard I/O

Module In
---------

   Module `In' provides a set of basic read operations for text.  It is
initially set to read from the standard input channel
`StdChannels.stdin' (*note StdChannels::.), but this may be changed with
the `SetReader' procedure.

   Each of the procedures in this module is designed to interpret a
specific type of text token.  That is, `Char' will read in a single
`CHAR' value, `Int' will read in an `INTEGER' value, and so forth.  For
exact syntax of each of these tokens see *Note Syntax of Text Tokens::.

   The following program fragment gives an example of how you could
read input a single line at a time (input stops after reading a blank
line):

     VAR str: ARRAY 256 OF CHAR;
     
       In.Line(str);
       WHILE In.Done() & (str # "") DO
          (* process each line *)
          In.Line(str);
       END;

 - Read-only Variable: reader
     The reader used for all read operations in module `In'.  The type
     of `reader' is `TextRider.Reader', and it is initialized to refer
     to a text reader connected to the channel `StdChannels.stdin'.

     The `SetReader' procedure may be used to change this to refer to
     another `TextRider.Reader'.

 - Function: Done `(): BOOLEAN'
     This function returns `FALSE' after an unsuccessful read operation.
     This may be caused by attempting to read improperly formatted text
     (e.g., attempting to read non-numeric text using `Int'), or if the
     underlying reader has encountered an error.  Further reading is
     not possible until the error is cleared using the `ClearError'
     procedure.

 - Procedure: ClearError
     Clears error conditions, re-enabling further read operations.

 - Procedure: SetReader `(R: TextRider.Reader)'
     This procedure is used to change the reader used by all read
     operations in module `In'.  Refer to *Note TextRider:: for details
     on how to open other readers.  If R=NIL, the reader is set to read
     from `StdChannels.stdin'.

   All of the following read operations require that `Done()' =>
`TRUE'; that is, they will not read anything else after an unsuccessful
read operation has occured.  Further reading cannot take place until the
error is cleared using `ClearError'.

   Most of these read operations skip leading whitespace (i.e., spaces,
tabs, end-of-line characters, etc.) before reading a token; the only
procedures that do not skip whitespace are `Char' and `Line'.

   A read error will occur, not only for improperly formatted text, but
for numbers (i.e., reading using `Int', `Real', and so forth) and set
elements that have values out of range of the target type.  For example,
attempting to read `999999999999999999' using `Int' will give `Done()'
=> `FALSE'.

   An error will also occur for procedures that read into an `ARRAY'
`OF' `CHAR', when the array is not large enough to hold the entire
input.

 - Procedure: Bool `(VAR BOOL: BOOLEAN)'
     Reads in the text `TRUE' or `FALSE'; any other text results in an
     error.  When an error occurs, the value of BOOL is undefined.

 - Procedure: Char `(VAR CH: CHAR)'
     Reads in a single character.

 - Procedure: Hex `(VAR LINT: LONGINT)'
     Reads in text in the form of an unsigned hexadecimal number.  The
     first character must be a decimal digit (i.e., `0..9') and
     subsequent characters must be valid hexadecimal digits (i.e.,
     `0..9' or `A..F').  The value read must be in the valid range for a
     `LONGINT'.

     Upon encountering an error, the value of LINT is undefined.

     *Please note:* Because `LONGINT' values are signed, hex numbers in
     the range `80000000H..FFFFFFFFH' are interpreted as negative
     `LONGINT' values.

 - Procedure: Identifier `(VAR S: ARRAY OF CHAR)'
     Reads an Oberon-2 style identifier.  The first character must be a
     letter, which is followed by any sequence of letters and digits.
     An error will occur if S is not large enough to hold the entire
     input.

     Upon encountering an error, the value of S is undefined.
     *Example:*

          (* Input is as follows:
          myIdentifier 3isBad
          *)
          
          VAR str: ARRAY 256 OF CHAR;
          
          In.Identifier(str)
             => Done() = TRUE, str = "myIdentifier"
          In.Identifier(str)
             => Done() = FALSE, str = undefined

 - Procedure: Int `(VAR INT: INTEGER)'
     Reads in text in the form of a signed whole number.  The first
     character must be a digit, a "`+'" sign, or a "`-'" sign.  The
     value read must be in the valid range for an `INTEGER'.

     Upon encountering an error, the value of INT is undefined.

     *Example:*

          (* Input is as follows:
          12345
          999999999999999
          forty-two
          *)
          
          VAR intVar: INTEGER;
          
          In.Int(intVar);
             => Done() = TRUE, intVar = 12345
          In.Int(intVar);
             => Done() = FALSE, intVar = undefined
          In.ClearError;
          In.Int(intVar); (* attempting to read `forty-two' *)
             => Done() = FALSE, intVar = undefined
                  (* reading position is still at the `f' in
                     `forty-two' *)

 - Procedure: LongInt `(VAR LINT: LONGINT)'
     This procedure provides the same facility as `Int', except that it
     deals with `LONGINT' values.

 - Procedure: ShortInt `(VAR INT: SHORTINT)'
     This procedure provides the same facility as `Int', except that it
     deals with `SHORTINT' values.

 - Procedure: Line `(VAR S: ARRAY OF CHAR)'
     Reads text until an end-of-line character is encountered.  The
     end-of-line character is discarded and S is always terminated with
     `0X'.  An error will occur if S is not large enough to hold the
     entire input.

     Upon encountering an error, the value of S is undefined.

     *Please note:* This procedure returns an empty string if already at
     at the end-of-line.

 - Procedure: String `(VAR S: ARRAY OF CHAR)'
     Reads in any text enclosed in single (`'') or double (`"') quote
     marks.  The opening quote must be the same as the closing quote
     and must not occur within the string.  Reading will continue until
     the terminating quote mark is encountered, an invalid character is
     read (end-of-line is always considered invalid), or there are no
     more characters available to be read.  S is always terminated with
     `0X'.

     Unquoted strings or strings with no terminating quote mark result
     in an error.  An error will also occur if S is not large enough to
     hold the entire input.

     Upon encountering an error, the value of S is undefined.

     *Example:*

          (* Input is as follows:
          "A well-formed string"
          "No end quote
          *)
          
          VAR str: ARRAY 256 OF CHAR;
          
          In.String(str);
             => Done() = TRUE, str = "A well-formed string"
          In.String(str);
             => Done() = FALSE, str = undefined
                  (* reading position is now at the end of this line *)

 - Procedure: Real `(VAR REAL: REAL)'
     Reads in text in the form of a signed fixed or floating-point
     number.  The first character must be a digit, a "`+'" sign, or a
     "`-'" sign.  The value read must be in the valid range for a
     `REAL'.

     Upon encountering an error, the value of REAL is undefined.

     *Example:*

          (* Input is as follows:
          3.1415
          +54321E+30
          2.34E+56
          *)
          
          VAR realVar: REAL;
          
          In.Real(realVar);
             => Done() = TRUE, realVar = 3.141500
          In.Real(realVar);
             => Done() = TRUE, realVar = 5.432100E+34
          In.Real(realVar);
             => Done() = FALSE, realVar = undefined
                  (* value is out of range for REAL *)

 - Procedure: LongReal `(VAR LREAL: LONGREAL)'
     This procedure provides the same facility as `Real', except that it
     deals with `LONGREAL' values.

 - Procedure: Set `(VAR S: SET)'
     Reads in text in the form of a set constructor.  The values of set
     elements must be in the range `0..MAX(SET)'.

     Upon encountering an error, the value of S is undefined.

     *Example:*

          (* Input is as follows:
          {0, 1, 2, 3, 4, 5}
          {6, 7, 1024}
          *)
          
          VAR setVar: SET;
          
          In.Set(setVar);
             => Done() = TRUE, setVar = {0..5}
          In.Set(setVar);
             => Done() = FALSE, setVar = undefined
                  (* reading position is now at the `}' after
                     the `1024' *)


File: OOCref.info,  Node: Out,  Next: Err,  Prev: In,  Up: Standard I/O

Module Out
----------

   Module `Out' provides a set of basic write operations for text.  It
is initially set to write to the standard output channel
`StdChannels.stdout' (*note StdChannels::.), but this may be changed
with the `SetWriter' procedure.

 - Read-only Variable: writer
     The writer used for all write operations in module `Out'.  The
     type of `writer' is `TextRider.Writer', and it is initialized to
     refer to a text reader connected to the channel
     `StdChannels.stdout'.

     The `SetWriter' procedure may be used to change this to refer to
     another `TextRider.Writer'.

 - Function: Done `(): BOOLEAN'
     This function returns `FALSE' after an unsuccessful write
     operation.  This may happen when underlying writer has encountered
     an error.  Further writing is not possible until the error is
     cleared using the `ClearError' procedure.

 - Procedure: ClearError
     Clears error conditions, re-enabling further read operations.

 - Procedure: SetWriter `(W: TextRider.Writer)'
     This procedure is used to change the writer used by all write
     operations in module `Out'.  Refer to *Note TextRider:: for
     details on how to open other writers.  If W=NIL, the writer is set
     to write to `StdChannels.stdout'.

 - Procedure: Flush
     Flushes all buffers associated with `Out.writer'.  Any pending
     write operations are passed to the underlying system.  If a
     writing error occurs while flushing buffers, `Out.Done()' will
     subsequently return `FALSE'.  Otherwise, `Out.Done()' will return
     `TRUE'.

 - Procedure: Bool `(BOOL: BOOLEAN)'
     Writes the value of BOOL as text.  That is, either `TRUE' or
     `FALSE'.

 - Procedure: Char `(CH: CHAR)'
     Writes a single character value CH.

     *Example:*

          Out.Char("A");
             => writes one character = "A"

 - Procedure: Hex `(LINT: LONGINT; N: LONGINT)'
     Writes the value of LINT as an unsigned hexadecimal number with a
     minimum field width of N.  Leading zeros are written if the value
     of LINT requires less than N places.  If N is less than or equal
     to zero, field width is 8.

     *Example:*

          Out.Hex(127, 4);
             => writes "007F"
          Out.Hex(-128, 0);
             => writes "FFFFFF80"

 - Procedure: Int `(INT: INTEGER; N: LONGINT)'
     Writes the value of INT as a decimal number with a minimum field
     width of N.  Leading spaces are written if the value of INT
     requires less than N places.  A sign is written only for negative
     values.

     *Example:*

          Out.Int(54321, 0);
             => writes "54321"
          Out.Int(54321, 10);
             => writes "     54321"

 - Procedure: LongInt `(LINT: LONGINT; N: LONGINT)'
     This procedure provides the same facility as `Int', except that it
     deals with `LONGINT' values.

 - Procedure: ShortInt `(SINT: SHORTINT; N: LONGINT)'
     This procedure provides the same facility as `Int', except that it
     deals with `SHORTINT' values.

 - Procedure: Real `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a floating-point number with a minimum
     field width of N.

     If the value of K is greater than 0, that number of significant
     digits is included.  Otherwise, an implementation-defined number
     of significant digits is included.  The decimal point is not
     included if there are no significant digits in the fractional part.

     The number is scaled with one digit in the whole number part.  A
     sign is included only for negative values.

     *Example:*

          Out.Real(3923009, 0, 0);
             => writes "3.923009E+6"
          Out.Real(3923009, 10, 1);
             => writes "      4E+6"
          
          Out.Real(-39.23009, 12, 2);
             => writes "     -3.9E+1"
          
          Out.Real(0.0003923009, 6, 1);
             => writes "  4E-4"

 - Procedure: LongReal `(LREAL: LONGREAL; N, K: LONGINT)'
     This procedure provides the same facility as `Real', except that it
     deals with `LONGREAL' values.

 - Procedure: RealEng `(REAL: REAL; N, K: LONGINT)'
     This procedure provides the same facility as `Real', except that
     the number is scaled with one to three digits in the whole number
     part and has an exponent that is a multiple of three.

     *Example:*

          Out.RealEng(39.23009, 10, 5);
             => writes "    39.230"
          
          Out.RealEng(-3923009, 7, 3);
             => writes " -3.92E+6"
          
          Out.RealEng(0.0003923009, 1, 1);
             => writes "400E-6"
          Out.RealEng(0.0003923009, 4, 2);
             => writes "  390E-6"

 - Procedure: LongRealEng `(LREAL: LONGREAL; N, K: LONGINT)'
     This procedure provides the same facility as `RealEng', except
     that it deals with `LONGREAL' values.

 - Procedure: RealFix `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a fixed-point number with a minimum
     field width of N.

     The value is rounded to the given value of K relative to the
     decimal point.  The decimal point is suppressed if K is less than
     0.

     The number will have at least one digit in the whole number part.
     A sign is included only for negative values.

     *Example:*

          Out.RealFix(3923009, 0, -5);
             => writes "3920000"  (* rounded to the
                                  ten-thousands place *)
          
          Out.RealFix(3923.5, 0, -1);
             => writes "3924" (* rounded to the "ones" place *)
          
          Out.RealFix(-39.23009, 10, 1);
             => writes "     -39.2"
          
          Out.RealFix(0.0003923009, 11, 4);
             => writes "     0.0004"

 - Procedure: LongRealFix `(LREAL: LONGREAL; N, K: LONGINT)'
     This procedure provides the same facility as `RealFix', except
     that it deals with `LONGREAL' values.

 - Procedure: Set `(S: SET)'
     Writes the value of S as an Oberon-2 set constructor, including
     curly braces, commas, and range indicators (`..') where
     appropriate.

     *Example:*

          Out.Set({1,6,10});
             => writes "{1, 6, 10}"
          Out.Set({0, 1, 2, 3, 4, 5});
             => writes "{0..5}"
          Out.Set({0, 2, 4, 6} + {1, 3, 5, 7});
             => writes "{0..7}"

 - Procedure: String `(S: ARRAY OF CHAR)'
     Writes a string value up to, but not including, the terminating
     `0X' character.  The behaviour of this procedure is undefined if S
     is an unterminated character array.

     *Please note:* `In.String' and `Out.String' *are not* symmetric.
     That is,
     `Out.String' does not enclose the written string in quote marks;
     only the actual character values contained in S are written.

 - Procedure: Ln
     Writes an end-of-line marker (i.e., a "newline").


File: OOCref.info,  Node: Err,  Prev: Out,  Up: Standard I/O

Module Err
----------

   Module `Err' provides a set of basic write operations for text, which
exactly mirror those in module `Out'.  The difference is that `Err' is
initially set to write to the standard error channel
`StdChannels.stderr' (*note StdChannels::.).  Also note that the call
`Err.SetWriter(NIL)' will reset the writer for `Err' to
`StdChannels.stderr'.

   Because the interfaces of `Out' and `Err' are identical, decriptions
of facilities are not duplicated here.


File: OOCref.info,  Node: Mathematics,  Next: Date and Time,  Prev: I/O Subsystem,  Up: Top

Mathematics
***********

   The mathematics modules described in this chapter serve several
purposes.  They provide access to the underlying representation of
`REAL' and `LONGREAL' values, as well as facilities for common
mathematical functions and constants.

   The `REAL' and `LONGREAL' types, collectively referred to as the
"real numeric types", are used to represent "floating-point numbers",
which may be stored in various ways on a computer.  The actual values
are approximations of real numbers and may not be wholely accurate.
Hence, precise details of the floating-point representation are often
required when creating operations that involve real numeric types in
order to minimize errors and calculate error bounds.

   A full discourse on floating-point numbers, as well as more complete
descriptions of algorithms used for manipulating floating-point data, is
beyond the scope of this manual.  For further information, consult the
following references:

`IEEE Standard for Binary Floating-Point Arithmetic'
(ANSI/IEEE STD 754-1985) (R1990)
Institute of Electrical and Electronics Engineers, Inc. (IEEE)

`IEEE Standard for Radix-Independent Floating-Point Arithmetic'
(ANSI/IEEE STD 854-1987) (R1994)
Institute of Electrical and Electronics Engineers, Inc. (IEEE)

`Information technology -- Language independent arithmetic --
Part 1: Integer and floating point arithmetic'
(ISO/IEC 10967-1:1994(E))
International Organization for Standardization (ISO)

`What Every Computer Scientist Should Know About Floating-Point Arithmetic'
David Goldberg
ACM Computing Surveys, Vol. 23, No. 1, March 1991, pp. 5-48

`Software Manual for the Elementary Functions'
William James Cody
Prentice Hall, July 1980

`Computer Approximations'
John F. Hart
Krieger Publishing Company, June 1978

* Menu:

* Low-level Numeric Properties:: Access to underlying properties of types
                                  `REAL' and `LONGREAL'.
* Mathematical Functions::      Mathematical functions on `REAL'
                                  and `LONGREAL' values.
* Arbitrary Precision Integers:: Arbitrary precision integer operations.
* Arbitrary Precision Real Numbers:: Arbitrary precision operations on
                                  real numbers.
* Complex Numbers::             Mathematical functions for types
                                  `COMPLEX' and `LONGCOMPLEX'.
* Random Numbers::              Psuedo-random number generators.


File: OOCref.info,  Node: Low-level Numeric Properties,  Next: Mathematical Functions,  Up: Mathematics

Low-level Numeric Properties
============================

   The modules `LowReal' and `LowLReal' give access to the underlying
properties of the types `REAL' and `LONGREAL'.

   Default properties of the real numeric types are defined by the
constants in these modules.  (An implementation may provide facilities
for dynamically changing properties from these defaults.)

   *Please note:*

   * The value of PLACES, and the other facilities in these modules,
     refers only to the representation used to store values.  It is
     possible for expressions to be computed to greater precision than
     that used to store values.

   * If the implementation of the corresponding real numeric type
     conforms to `ISO/IEC 10967-1:199x (LIA-1)', the following
     correspondences hold:

          OOC lib         LIA-1
          --------        --------
          radix           r
          places          p
          gUnderflow      denorm
          small           fmin_N
          expoMin         emin
          expoMax         emax

   * The value of the parameter `fmax', which is required by `ISO/IEC
     10967-1:199x', is given by the predefined function `MAX' when
     applied to the corresponding real numeric type.

 - Constant: radix
     The whole number value of the radix (base number system) used to
     represent the corresponding real number values.  (Most modern
     computers use IEEE 754, which defines the radix to be 2.)

 - Constant: places
     A whole number value representing of the number of `radix' places
     used to store values of the corresponding real numeric type.

 - Constant: expoMax
     A whole number value representing the largest possible exponent of
     the corresponding real numeric type.

 - Constant: expoMin
     A whole number value representing the smallest possible exponent
     of the corresponding real numeric type.

     *Please note:* It is possible that `expoMin = expoMax', which is
     likely for the case of fixed point representation.

 - Constant: large
     The largest possible value of the corresponding real numeric type.

     *Please note:* On some systems, `large' may be a machine
     representation of infinity.

 - Constant: small
     The smallest possible positive value of the corresponding real
     numeric type, represented to maximal precision.

     *Please note:* If an implementation has stored values strictly
     between `0.0' and `small', then presumbly the implementation
     supports gradual underflow.

 - Constant: IEC559
     A boolean value that is `TRUE' if, and only if, the implementation
     of the corresponding real numeric type conforms to `IEC 559:1989
     (IEEE 754:1987)' in all regards.

     *Please note:*
        * If `IEC559' is `TRUE', the value of `radix' is `2'.

        * If `LowReal.IEC559' is `TRUE', the 32-bit format of `IEC
          559:1989' is used for the type `REAL'.

        * If `LowLReal.IEC559' is `TRUE', the 64-bit format of `IEC
          559:1989' is used for the type `LONGREAL'.

 - Constant: LIA1
     A boolean value that is `TRUE' if, and only if, the implementation
     of the corresponding real numeric type conforms to `ISO/IEC
     10967-1:199x (LIA-1)' in all regards: parameters, arithmetic,
     exceptions, and notification.

 - Constant: rounds
     A boolean value that is `TRUE' if, and only if, each operation
     produces a result that is one of the values of the corresponding
     real numeric type nearest to the mathematical result.

     *Please note:* If `rounds' is `TRUE', and the mathematical result
     lies mid-way between two values of the corresponding real numeric
     type, then the selection from the two possible values is
     implementation-dependent.

 - Constant: gUnderflow
     A boolean value that is `TRUE' if, and only if, there are values
     of the corresponding real numeric type between `0.0' and `small'.

 - Constant: exception
     A boolean value that is `TRUE' if, and only if, every operation
     that attempts to produce a real value out of range raises an
     exception.

 - Constant: extend
     A boolean value that is `TRUE' if, and only if, expressions of the
     corresponding real numeric type are computed to higher precision
     than the stored values.

     *Please note:* If `extend' is `TRUE', then values greater than
     `large' can be computed in expressions, but cannot be stored in
     variables.

 - Constant: nModes
     A whole number value giving the number of bit positions needed for
     the status flags for mode control.

 - Data type: Modes = SET
     This type is used to represent the status flags that apply to the
     underlying implementation of the corresponding real numeric type.
     This type is used for the `setMode' and `currentMode()' procedures.

   The following functions are provided in either `LowReal' (for
`REAL') or `LowLReal' (for `LONGREAL'):

 - Function: exponent `(X: REAL): INTEGER'

 - Function: exponent `(X: LONGREAL): INTEGER'
     This function returns the exponent value of X, which must lie
     between `expoMin' and `expoMax'.  If `X=0.0', an exception occurs
     and may be raised.

 - Function: fraction `(X: REAL): REAL'

 - Function: fraction `(X: LONGREAL): LONGREAL'
     This function returns the significand (or significant) part of X.
     Hence, the following relationship holds:

          X = scale(fraction(X), exponent(X))

 - Function: IsInfinity `(REAL: REAL): BOOLEAN'

 - Function: IsInfinity `(REAL: LONGREAL): BOOLEAN'
     This function returns `TRUE' if, and only if, REAL is a
     representation of Infinity (either positive or negative).

 - Function: IsNaN `(REAL: REAL): BOOLEAN'

 - Function: IsNaN `(REAL: LONGREAL): BOOLEAN'
     This function returns `TRUE' if, and only if, REAL is a NaN ("Not
     a Number") representation.

     *Please note:* The routines `IsInfinity' and `IsNaN' allow, for
     example, for string formatting routines to have a reasonably
     portable way to check whether they are dealing with out of range
     or illegal numbers.

 - Function: sign `(X: REAL): REAL'

 - Function: sign `(X: LONGREAL): LONGREAL'
     This function returns the sign of X as follows:

       If `x > 0.0', return `1.0'
       If `x = 0.0', return either `1.0' or `-1.0'
       If `x < 0.0', return `-1.0'

     *Please note:* The uncertainty about the handling of `0.0' is to
     allow for systems that distinguish between `+0.0' and `-0.0' (such
     as IEEE 754 systems).

 - Function: succ `(X: REAL): REAL'

 - Function: succ `(X: LONGREAL): LONGREAL'
     This function returns the next value of the corresponding real
     numeric type greater than X, if such a value exists; otherwise, an
     exception occurs and may be raised.

 - Function: ulp `(X: REAL): REAL'

 - Function: ulp `(X: LONGREAL): LONGREAL'
     This function returns the value of the corresponding real numeric
     type equal to a unit in the last place of X, if such a value
     exists; otherwise, an exception occurs and may be raised.

     *Please note:* When this value exists, one, or both, of the
     following is true: `ulp(x) = succ(x)-x' or `ulp(x) = x-pred(x)'.

 - Function: pred `(X: REAL): REAL'

 - Function: pred `(X: LONGREAL): LONGREAL'
     This function returns the next value of the corresponding real
     numeric type less than X, if such a value exists; otherwise, an
     exception occurs and may be raised.

 - Function: intpart `(X: REAL): REAL'

 - Function: intpart `(X: LONGREAL): LONGREAL'
     This function returns the integral part of X.  For negative values,
     this is `-intpart(abs(X))'.

 - Function: fractpart `(X: REAL): REAL'

 - Function: fractpart `(X: LONGREAL): LONGREAL'
     This function returns the fractional part of X.  This satisfies the
     relationship `fractpart(X) + intpart(X) = X'.

 - Function: scale `(X: REAL; N: INTEGER): REAL'

 - Function: scale `(X: LONGREAL; N: INTEGER): LONGREAL'
     This function returns `X*radix^n', if such a value exists;
     otherwise, an exception occurs and may be raised.

 - Function: trunc `(X: REAL; N: INTEGER): REAL'

 - Function: trunc `(X: LONGREAL; N: INTEGER): LONGREAL'
     This function returns the value of the most significant N places of
     X.  If N is less than or equal to zero, an exception occurs and
     may be raised.

 - Function: round `(X: REAL; N: INTEGER): REAL'

 - Function: round `(X: LONGREAL; N: INTEGER): LONGREAL'
     This function returns the value of X rounded to the most
     significant N places.  If such a value does not exist, or if N is
     less than or equal to zero, an exception occurs and may be raised.

 - Function: synthesize `(EXPART: INTEGER; FRAPART: REAL): REAL'

 - Function: synthesize `(EXPART: INTEGER; FRAPART: LONGREAL): LONGREAL'
     This function returns a value of the corresponding real numeric
     type contructed from the value of EXPART and FRAPART.  This value
     satisfies the relationship

          synthesize(exponent(X), fraction(X)) = X.

 - Procedure: setMode `(M: Modes)'
     This procedure sets status flags from the value of M, appropriate
     to the underlying implementation of the corresponding real numeric
     type.

     *Please note:*
        * Many implementations of floating-point provide options for
          setting flags within the system, which control details of the
          handling of the type.  Although two procedures are provided,
          one for each real numeric type, the effect may be the same.
          Typical effects that can be obtained by this means are as
          follows:

             * Ensuring that overflow will raise an exception.

             * Allowing underflow to raise an exception.

             * Controlling the rounding.

             * Allowing special values to be produced (e.g., `NaN's in
               implementations conforming to `IEC 559:1989 (IEEE
               754:1987)').

             * Ensuring that special value access will raise an
               exception.

          Because these effects are so varied, the values of type
          `Modes' that may be used are not specified by this manual.

        * The effect of `setMode' on operations on values of the
          corresponding real numeric type in processes other than the
          calling process is not defined.  Implementations are not
          required to preserve the status flags (if any) with the
          process state.

 - Function: currentMode `(): Modes'
     This function returns the current status flags (in the form set by
     `setMode'), or the default status flags (if `setMode' is not used).

     *Please note:* The returned value is not necessarily the value set
     by `setMode', because a call of `setMode' might attempt to set
     flags that cannot be set by the program.

 - Function: IsLowException `(): BOOLEAN'
     This function returns `TRUE' if the current process is in the
     exceptional execution state because of the raising of the
     corresponding `LowReal' or `LowLReal' exception; otherwise, it
     returns `FALSE'.

