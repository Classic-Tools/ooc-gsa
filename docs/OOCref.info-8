This is Info file OOCref.info, produced by Makeinfo version 1.68 from
the input file OOCref.texinfo.

   This file documents the Optimizing Oberon-2 Compiler (OOC) and its
library.

   This is Edition 0.10 DRAFT, last updated 29 February 2000, of `The
OOC Library Reference Manual', for Version 1.5.1 or later of oo2c.

   Copyright (C) 1997-2000 Eric Nikitin Part II Copyright (C) 1998-2000
Michael van Acken

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: OOCref.info,  Node: Mathematical Functions,  Next: Arbitrary Precision Integers,  Prev: Low-level Numeric Properties,  Up: Mathematics

Mathematical Functions
======================

   The modules `RealMath' and `LRealMath' provide facilities for common
mathematical functions and constants for `REAL' and `LONGREAL' numeric
types.

   *Please note:* The angle in all trigonometric functions is measured
in radians.

   The following useful mathematical constants are provided:

 - Constant: pi
     An implementation-defined approximation to the mathematical
     constant "pi".

 - Constant: exp1
     An implementation-defined approximation to the mathematical
     constant "e".

   *Please note:* Due to the approximations involved, `sin(pi)' might
not exactly equal zero.  Similarly, `exp1' might not exactly equal
`exp(1)'.

   The following are mathematical functions provided in either
`RealMath' (for `REAL') or `LRealMath' (for `LONGREAL'):

 - Function: sqrt `(X: REAL): REAL'

 - Function: sqrt `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the positive square root
     of X.  If X is negative, an exception is raised.

 - Function: exp `(X: REAL): REAL'

 - Function: exp `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the mathematical
     constant `e' raised to the power of X.

 - Function: ln `(X: REAL): REAL'

 - Function: ln `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the natural logarithm of
     X.  If X is zero or negative, an exception is raised.

 - Function: sin `(X: REAL): REAL'

 - Function: sin `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the sine of X for all
     values of X.

 - Function: cos `(X: REAL): REAL'

 - Function: cos `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the cosine of X for all
     values of X.

 - Function: tan `(X: REAL): REAL'

 - Function: tan `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the tangent of X.  If X
     is an odd multiple of `pi/2', an exception is raised.

 - Function: arcsin `(X: REAL): REAL'

 - Function: arcsin `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the arcsine of X.  The
     result will be in the range `[-pi/2, pi/2]'.  If the absolute
     value of X is greater than one, an exception is raised.

 - Function: arccos `(X: REAL): REAL'

 - Function: arccos `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the arccosine of X.  The
     result will be in the range `[0, pi]'.  If the absolute value of X
     is greater than one, an exception is raised.

 - Function: arctan `(X: REAL): REAL'

 - Function: arctan `(X: LONGREAL): LONGREAL'
     This function returns an approximation to the arctangent of X for
     all values of X.  The result will be in the range `[-pi/2, pi/2]'.

 - Function: power `(BASE, EXPONENT: REAL): REAL'

 - Function: power `(BASE, EXPONENT: LONGREAL): LONGREAL'
     This function returns an approximation to the value of BASE raised
     to the power EXPONENT.  If BASE is zero or negative, an exception
     is raised.

     *Please note:* This function is mathematically equivalent to
     `exp(EXPONENT * ln(BASE))', but may be computed differently.

 - Function: round `(X: REAL): LONGINT'

 - Function: round `(X: LONGREAL): LONGINT'
     This function returns the nearest integer to the value of X.  If
     the mathematical result is not within the range of the type
     `LONGINT', an exception occurs and may be raised.

     *Please note:* If the value of X is midway between two integer
     values, the result is an implementation-defined selection of one
     of the two possible values.

 - Function: IsRMathException `(): BOOLEAN'
     This function returns `TRUE' if the current process is in the
     exceptional execution state because of the raising of the
     corresponding `RealMath' or `LRealMath' exception; otherwise, it
     returns `FALSE'.


File: OOCref.info,  Node: Arbitrary Precision Integers,  Next: Arbitrary Precision Real Numbers,  Prev: Mathematical Functions,  Up: Mathematics

Arbitrary Precision Integers
============================

   Very often, a program requires numbers with a greater range or
accuracy than exists with the built-in Oberon-2 integer types.  Hence,
the module `Integers' provides facilities for "arbitrary precision"
integer operations.

   For further information on how these kinds of facilites may be
implemented, consult the following reference:

`The Art Of Computer Programming:
Volume 2, Seminumerical Algorithms, Second Edition'
Donald E. Knuth
Addison-Wesley Publishing Co., January 1981

 - Data type: Integer = POINTER TO IntegerDesc
     Instances of this type are used to represent arbitrary precision
     integers.

   The following operations are used to create initial instances of
`Integer' and convert `Integer's to standard numeric types.

 - Function: Entier `(X: LONGREAL): Integer'
     This function returns an instance of `Integer' whose value is the
     largest integer not greater than X.

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.Entier(1.0D20);
        => n = 100000000000000000000
     
     n:=Integers.Entier(1111111111.5D0);
        => n = 1111111111
     
     n:=Integers.Entier(0.0);
        => n = 0

 - Function: Float `(X: Integer): LONGREAL'
     This function returns an approximation to the value of X converted
     to a `LONGREAL'.  If the result cannot be represented as a
     `LONGREAL' because the value of X is either too large or too
     small, this function returns either `MIN(LONGREAL)' or
     `MAX(LONGREAL)'.

 - Function: Long `(X: LONGINT): Integer'
     This function returns an instance of `Integer' whose value is X.

 - Function: Short `(X: Integer): LONGINT'
     This function returns the value of X converted to a `LONGINT'.  If
     the result cannot be represented as a `LONGINT' because the value
     of X is either too large or too small, this function returns either
     `MIN(LONGINT)' or `MAX(LONGINT)'.

   *Example:*

     VAR n: Integers.Integer;
         s: LONGINT;
         f: LONGREAL;
     
     n:=Integers.Long(1234);
     s:=Integers.Short(n);
        => s = 1234
     f:=Integers.Float(n);
        => f = 1.23400000000000E+3
     
     n:=Integers.Long(80000000H);
     s:=Integers.Short(n);
        => s = -2147483648
     f:=Integers.Float(n);
        => f = -2.14748364800000E+9
     
     n:=Integers.Long(7FFFFFFFH);
     s:=Integers.Short(n);
        => s = 2147483647
     f:=Integers.Float(n);
        => f = 2.14748364700000E+9

   The following are common mathematical operations, which operate on
`Integer's:

 - Function: Abs `(X: Integer): Integer'
     This function returns the absolute value of X.

 - Function: Odd `(X: Integer): BOOLEAN'
     This function returns `TRUE' if X is an odd number, and `FALSE' if
     it is even.

 - Function: Compare `(X, Y: Integer): LONGINT'
     This function compares the values of X and Y and gives the
     following result:

       If `x > y', return `1'
       If `x = y', return `0'
       If `x < y', return `-1'

 - Function: Difference `(X, Y: Integer): Integer'
     This function returns the difference of X and Y (i.e., `x-y').

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.Difference(Integers.Long(2000000), Integers.Long(999));
        => n = 1999001
     
     n:=Integers.Difference(Integers.Long(999), Integers.Long(-2000000));
        => n = -2000999
     
     n:=Integers.Difference(Integers.Long(-999), Integers.Long(999));
        => n = -1998
     
     n:=Integers.Difference(Integers.Long(-2000000), Integers.Long(-999));
        => n = -1999001

 - Function: Sum `(X, Y: Integer): Integer'
     This function returns the sum of X and Y (i.e., `x+y').

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.Sum(Integers.Long(999), Integers.Long(2000000));
        => n = 2000999
     
     n:=Integers.Sum(Integers.Long(999), Integers.Long(-2000000));
        => n = -1999001
     
     n:=Integers.Sum(Integers.Long(-999), Integers.Long(999));
        => n = 0
     
     n:=Integers.Sum(Integers.Long(-2000000), Integers.Long(-999));
        => n = -2000999

 - Function: Product `(X, Y: Integer): Integer'
     This function returns the product of X and Y (i.e., `x*y').

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.Product(Integers.Long(100000000), Integers.Long(100000000));
        => n = 10000000000000000
     
     n:=Integers.Product(Integers.Long(71234), Integers.Long(66000));
        => n = 4701444000

 - Function: Quotient `(X, Y: Integer): Integer'
     This function returns the quotient of X divided by Y (i.e., `x DIV
     y').

     *Pre-condition*: Y is not zero.

 - Function: Remainder `(X, Y: Integer): Integer'
     This function returns the remainder of X divided by Y (i.e., `x
     MOD y').

     *Pre-condition*: Y is not zero.

   *Example:*

     VAR m, n: Integers.Integer;
     
     n:=Integers.Quotient(Integers.Long(2000000000), Integers.Long(1234));
     m:=Integers.Remainder(Integers.Long(2000000000), Integers.Long(1234));
        => n = 1620745, m = 670
     
     n:=Integers.Quotient(Integers.Long(2000000000), Integers.Long(123456));
     m:=Integers.Remainder(Integers.Long(2000000000), Integers.Long(123456));
        => n = 16200, m = 12800

 - Procedure: QuoRem `(X, Y: Integer; VAR QUO, REM: Integer)'
     This procedure calculates both the quotient and remainder of X
     divided by Y.

     *Pre-condition*: Y is not zero.

   *Example:*

     VAR m, n: Integers.Integer;
     
     Integers.QuoRem(Integers.Long(2000000000), Integers.Long(1234), n, m);
        => n = 1620745, m = 670
     
     Integers.QuoRem(Integers.Long(2000000000), Integers.Long(123456), n, m);
        => n = 16200, m = 12800

 - Function: GCD `(X, Y: Integer): Integer'
     This function returns the greatest common divisor of X and Y.

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.GCD(Integers.Long(40902), Integers.Long(24140));
        => n = 34
     
     n:=Integers.GCD(Integers.Long(27182818), Integers.Long(10000000));
        => n = 2
     
     n:=Integers.GCD(Integers.Long(2940), Integers.Long(238));
        => n = 14

 - Function: Power `(X: Integer; EXP: LONGINT): Integer'
     This function returns the value of X raised to the power EXP.

     *Pre-condition*: EXP is greater than zero.

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.Power(Integers.Long(2940), 2);
        => n = 8643600
     
     n:=Integers.Power(Integers.Long(2), 33);
        => n = 8589934592
     
     n:=Integers.Power(Integers.Long(10), 9);
        => n = 1000000000
     
     n:=Integers.Power(Integers.Long(2), 100);
        => n = 1267650600228229401496703205376

 - Function: Sign `(X: Integer): SHORTINT'
     This function returns the sign of X as follows:

       If `x > 0', return `1'
       If `x = 0', return `0'
       If `x < 0', return `-1'

 - Function: Factorial `(X: LONGINT): Integer'
     This function returns X factorial (i.e.,
     `x!=x(x-1)(x-2)...(2)(1)').

     *Pre-condition*: X is not negative.

   *Example:*

     VAR n: Integers.Integer;
     
     n:=Integers.Factorial(13);
        => n = 6227020800
     
     n:=Integers.Factorial(20);
        => n = 2432902008176640000

   The following operations are used to extract pieces of `Integers':

 - Function: ThisDigit10 `(X: Integer; EXP10: LONGINT): CHAR'
     This function returns a single character, which represents the
     digit in X located at position EXP10.  Note that the right most
     digit (i.e., the "ones" place) has position zero.

     *Pre-condition*: EXP10 is not negative.

   *Example:*

     VAR n: Integers.Integer;
         c: CHAR;
     
     Integers.ConvertFromString("1267650600228229401496703205376", n);
     
     c:=Integers.ThisDigit10(n, 0);
        => c = "6"
     
     c:=Integers.ThisDigit10(n, 10);
        => c = "9"
     
     c:=Integers.ThisDigit10(n, 30);
        => c = "1"

 - Function: Digits10Of `(X: Integer): LONGINT'
     This function returns the value of the last ten digits of X (i.e.,
     it returns `x MOD 1000000000').

   *Example:*

     VAR n: Integers.Integer;
         s: LONGINT;
     
     Integers.ConvertFromString("1267650600228229401496703205376", n);
     
     s:=Integers.Digits10Of(n);
        => s = 703205376

   The following operations are used to convert between strings and
`Integer's:

 - Procedure: ConvertFromString `(S: ARRAY OF CHAR; VAR X: Integer)'
     This procedure converts S to an `Integer' value, which is assigned
     to X.  Leading spaces and tab characters in S are skipped.

     *Pre-condition*: S is in the form of a signed whole number (*note
     Syntax of Text Tokens::.)

 - Procedure: ConvertToString `(X: Integer; VAR S: ARRAY OF CHAR)'
     This procedure converts X to a string value, which is assigned to
     S.

   *Example:*

     VAR n: Integers.Integer;
         str: ARRAY 1024 OF CHAR;
     
     Integers.ConvertFromString("1234567890", n);
        => n = 1234567890
     Integers.ConvertToString(n, str);
        => str = "1234567890"
     
     Integers.ConvertFromString("  -9999999999", n);
        => n = -9999999999
     Integers.ConvertToString(n, str);
        => str = "-9999999999"
     
     Integers.ConvertFromString(" 12345678901234567890123456789", n);
        => n = 12345678901234567890123456789
     Integers.ConvertToString(n, str);
        => str = "12345678901234567890123456789"

   The following operations can be used to internalize and externalize
`Integers' (i.e., read from and write to channels):

 - Procedure: Externalize `(VAR W: BinaryRider.Writer; X: Integer)'
     Writes the value of X to a channel using writer W.

 - Procedure: Internalize `(VAR R: BinaryRider.Reader; VAR X: Integer)'
     Retrieves a stored `Integer' value from a channel using reader R,
     and assigns it to X.


File: OOCref.info,  Node: Arbitrary Precision Real Numbers,  Next: Complex Numbers,  Prev: Arbitrary Precision Integers,  Up: Mathematics

Arbitrary Precision Real Numbers
================================

   Module `Reals' provides facilities for arbitrary precision floating
point operations.  Real numbers are represented by type `Real'.

   These facilities are based on a FORTRAN library (MPFUN) created by
David H. Bailey.  For more information, see
`http://www.nersc.gov/~dhb/'

   or contact <mp-request@nas.nasa.gov>.

Numeric Precision-setting Constants
-----------------------------------

 - Constant: maxDigits
     Initial precision level in digits.

 - Constant: outDigits
     Initial output precision level in digits.

 - Constant: log10eps
     The initial multiprecision "epsilon" level.

 - Constant: maxMant
     Maximum mantissa precision in (machine) words.

 - Constant: maxExp
     Maximum exponent precision.

Types
-----

 - Data type: Real = POINTER TO RealDesc
     Instances of this type are used to represent arbitrary precision
     floating point numbers.

Variables
---------

 - Variable: err: INTEGER

 - Read-only Variable: curMant: INTEGER
     Current mantissa precision in (machine) words.

 - Read-only Variable: sigDigs: INTEGER

 - Read-only Variable: eps: Real
     Current multiprecision "epsilon" level.

 - Read-only Variable: ln2: Real
     An approximation of the value of the natural logarithm of `2'.

 - Read-only Variable: pi: Real
     An approximation of the mathematical constant "pi".

 - Read-only Variable: ln10: Real
     An approximation of the value of the natural logarithm of `10'.

Procedures
----------

   The following operations are used to create initial instances of
`Real' and convert `Real's to standard numeric types.

 - Function: Long `(X: LONGREAL): Real'
     This function returns an instance of `Real' whose value is X.

 - Function: Copy `(A: Real): Real'
     This function returns a new instance of `Real' that has the same
     value as A.

   The following operations are used to convert between strings and
`Reals':

 - Function: ToReal `(STR: ARRAY OF CHAR): Real'
     This procedure converts STR to a `Real' value and returns the
     result.

     The numeric representation of STR must be of the format

          number = ["+" | "-"] {decimal_digit} ["." {decimal_digit}] [scale]
          
          where  scale = ("E" | "D") ["+" | "-"] decimal_digit
                         {decimal_digit}
          and    decimal_digit = "0".."9" | " "

     Thus the following is a valid input:

          "1.23456 12938 23456 E + 200"

     *Please note:* This real number definition is backwardly compatible
     with the Oberon-2 real string, but it has been extended to allow
     splitting of very large numbers into more readable segments by
     inserting spaces.

 - Procedure: ToString `(A: Real; VAR STR: ARRAY OF CHAR; N: LONGINT)'
     This procedure converts A to a string value in scientific notation
     with N significant places.  The result it assigned to STR.  Note
     that the length of STR should be at least `N+15' characters.

 - Function: short `(Q: Real): LONGREAL'
     This function returns the value of Q converted to a `LONGREAL'
     value.  If the result cannot be represented as a `LONGREAL'
     because the value of Q is either too large or too small, this
     function returns either `MIN(LONGREAL)' or `MAX(LONGREAL)'.

 - Function: entier `(Q: Real): Real'
     This function returns an instance of `Real' whose value is the
     largest integer not greater than Q.

   *Example:*

     VAR n: Reals.Real;
     
     n:=entier(Reals.Long(3.6));  (* ENTIER(3.6) *)
        => n = 3.0E+0
     
     n:=entier(Reals.Long(-3.6));  (* ENTIER(-3.6) *)
        => n = -4.0E+0

 - Function: fraction `(Q: Real): Real'
     This function returns the fractional part of Q.

 - Function: add `(Z1, Z2: Real): Real'
     This function returns the sum of Z1 and Z2 (i.e., `z1+z2').

 - Function: sub `(Z1, Z2: Real): Real'
     This function returns the difference of Z1 and Z2 (i.e., `z1-z2').

 - Function: mul `(Z1, Z2: Real): Real'
     This function returns the product of Z1 and Z2 (i.e., `z1*z2').

 - Function: div `(Z1, Z2: Real): Real'
     This function returns the quotient of Z1 divided by Z2 (i.e.,
     `z1/z2').

     *Pre-condition*: Z2 is not zero.

   *Example:*

     VAR m, n, s: Reals.Real;
     
     m:=Reals.ToReal("0.123456789012345678901234567890123456790");
        => m = 1.234567890123456789012345678E-1
     
     n:=Reals.ToReal("123456789012345678901234567890123456789");
        => n = 1.234567890123456789012345678E+38
     
     s:=Reals.add(n, m);
        => s = 1.234567890123456789012345678E+38
     
     s:=Reals.sub(n, m);
        => s = 1.234567890123456789012345678E+38
     
     s:=Reals.div(n, m);
        => s = 1.0E+39
     
     s:=Reals.mul(n, m);
        => s = 1.524157875323883675049535156E+37
     
     
     s:=Reals.div(Reals.Long(1), Reals.Long(3));  (* 1/3 *)
        => s = 3.333333333333333333333333333E-1
     
     n:=Reals.add(s, s);  (* 1/3+1/3 *)
        => n = 6.666666666666666666666666666E-1
     
     s:=Reals.div(Reals.Long(1), Reals.Long(3));  (* 1/3 *)
        => s = 3.333333333333333333333333333E-1
     
     n:=Reals.mul(s, s);  (* 1/3*1/3 *)
        => n =1.111111111111111111111111111E-1
     
     s:=Reals.div(Reals.Long(1), Reals.Long(3));  (* 1/3 *)
        => s = 3.333333333333333333333333333E-1
     
     n:=Reals.mul(s, Reals.Long(3));  (* 1/3*3 *)
        => n = 1.0E+0

 - Function: abs `(Z: Real): Real'
     This function returns the absolute value of Z.

 - Function: cmp `(A, B: Real): LONGINT'
     This function compares the values of A and B and gives the
     following result:

       If `a > b', return `1'
       If `a = b', return `0'
       If `a < b', return `-1'

     Note that this operation is faster than merely subtracting A and B
     and examining the sign of the result.

 - Function: power `(X, EXP: Real): Real'
     This function returns the value of X raised to the power EXP.

     *Pre-condition*: EXP is greater than zero.

   *Example:*

     VAR n: Reals.Real;
     
     n:=Reals.power(Reals.Long(2.0), Reals.Long(64));  (* 2^64 *)
        => n = 1.8446744073709551616E+19

 - Function: root `(Z: Real; N: LONGINT): Real'
     This function returns the value of the Nth root of Z.

     *Pre-condition*: Z is non-negative.

   *Example:*

     VAR n: Reals.Real;
     
     n:=Reals.root(Reals.Long(-8), 3);  (* -8^(-1/3) *)
        => n = -2.0E+0
     
     n:=Reals.root(Reals.power(Reals.Long(2), Reals.Long(64)), 64);
        => n = 2.0E+0    (* (2^64)^(-1/64) *)

 - Function: sqrt `(Z: Real): Real'
     This function returns the principal square root of Z.  The value of
     the result is in the range `[-pi/2, pi/2]'.

     *Pre-condition*: X is non-negative.

 - Function: exp `(Z: Real): Real'
     This function returns the complex exponential of Z (the
     mathematical constant `e' raised to the power of Z).

 - Function: ln `(Z: Real): Real'
     This function returns the principal value of the natural logarithm
     of Z.

     *Pre-condition*: Z is positive.

 - Function: log `(Z, BASE: Real): Real'
     This function returns the principal value of the base BASE
     logarithm of Z.

     *Pre-condition*: Z is positive.

   *Example:*

     VAR n: Reals.Real;
     
     n:=Reals.log(Reals.eps, Reals.Long(10));  (* log10(eps) *)
        => n = -4.9E+2

 - Function: sin `(Z: Real): Real'
     This function returns the sine of Z.

 - Function: cos `(Z: Real): Real'
     This function returns the cosine of Z.

 - Procedure: sincos `(Z: Real; VAR SIN, COS: Real)'
     This function returns both the sine and cosine of Z.

   *Example:*

     VAR m, n: Reals.Real;
     
     Reals.sincos(pi, m, n);
        => m = 0.0E+0  (* Sin(pi) *)
        => n =-1.0E+0  (* Cos(pi) *)
     
     Reals.sincos(div(pi, Reals.Long(8)), m, n);
        => m = 3.82683432365089771728459984E-1   (* Sin(pi/8) *)
        => n = 9.238795325112867561281831893E-1  (* Cos(pi/8) *)
     
     Reals.sincos(Reals.Long(1), m, n);
        => m = 8.414709848078965066525023216E-1  (* Sin(1) *)
        => n = 5.403023058681397174009366074E-1  (* Cos(1) *)

 - Function: tan `(Z: Real): Real'
     This function returns tangent of Z.

     *Pre-condition*: Z is not an odd multiple of `pi/2'.

 - Function: arcsin `(Z: Real): Real'
     This function returns the arcsine of Z.  The result is in the range
     `[-pi/2, pi/2]'.

     *Pre-condition*: the absolute value of Z is less than or equal to
     one.

   *Example:*

     VAR n: Reals.Real;
     
     n:=Reals.arcsin(Reals.sin(Reals.Long(1)));  (* arcsin(sin(1)) *)
        => n = 1.0E+0

 - Function: arccos `(Z: Real): Real'
     This function returns the arccosine of Z.  The result is in the
     range `[0, pi]'.

     *Pre-condition*: the absolute value of Z is less than or equal to
     one.

 - Function: arctan `(Z: Real): Real'
     This function returns the arctangent of Z.  The result is in the
     range `[-pi/2, pi/2]'.

   *Example:*

     VAR n: Reals.Real;
     
     n:=Reals.mul(Reals.Long(4), Reals.arctan(Reals.Long(1)));
        (* 4*arctan(1) *)
        => n = 3.141592653589793238462643383E+0

 - Function: arctan2 `(XN, XD: Real): Real'
     This function returns the arctangent of `XN/XD'.  The signs of the
     two arguments are taken into account when determining quadrant
     information.  The result is in the range `[-pi, pi]'.

 - Procedure: sinhcosh `(Z: Real; VAR SINH, COSH: Real)'
     This function returns both the hyberbolic sine and cosine of Z.

 - Function: sinh `(Z: Real): Real'
     This function returns the hyperbolic sine of Z.

 - Function: cosh `(Z: Real): Real'
     This function returns the hyperbolic cosine of Z.

 - Function: tanh `(Z: Real): Real'
     This function returns the hyperbolic tangent of Z.

 - Procedure: SetWords `(WORDS: INTEGER)'
     This procedure sets the value of the current mantissa precision in
     (machine) words (i.e., sets the value of `curMant').


File: OOCref.info,  Node: Complex Numbers,  Next: Random Numbers,  Prev: Arbitrary Precision Real Numbers,  Up: Mathematics

Complex Numbers
===============

   The modules `ComplexMath' and `LComplexMath' provide facilities for
complex numbers, which includes common mathematical functions for types
`COMPLEX' and `LONGCOMPLEX'.

   Instances of the following two classes are used to represent complex
numbers:

 - Data type: COMPLEX = POINTER TO COMPLEXDesc
     The *real* and *imaginary* parts of this type are represented as
     type `REAL'

 - Data type: LONGCOMPLEX = POINTER TO LONGCOMPLEXDesc
     The *real* and *imaginary* parts of this type are represented as
     type `LONGREAL'

   *Please note:* To create initial instances of `COMPLEX' and
`LONGCOMPLEX', you must use the corresponding `CMPLX()' function.

   The following are instances of the corresponding complex number
type.  They are provided for convenience and have values that represent
the specified complex number:

 - Read-only Variable: i
     The value of `i' is initialized to `CMPLX (0.0, 1.0)'.

 - Read-only Variable: one
     The value of `one' is initialized to `CMPLX (1.0, 0.0)'.

 - Read-only Variable: zero
     The value of `zero' is initialized to `CMPLX (0.0, 0.0)'.

   The following functions are provided in either `ComplexMath' (for
`COMPLEX') or
`LComplexMath' (for `LONGCOMPLEX'):

 - Function: CMPLX `(R, I: REAL): COMPLEX'

 - Function: CMPLX `(R, I: LONGREAL): LONGCOMPLEX'
     This function returns an instance of the corresponding complex
     number type whose real part has a value of R and imaginary part
     has a value of I.

 - Function: Copy `(Z: COMPLEX): COMPLEX'

 - Function: Copy `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns a copy of Z.

     *Please note:* This function provides the only reliable way to
     assign complex number values.  If `a' and `b' are complex numbers,
     *do not* use `a := b'.

 - Function: RealPart `(Z: COMPLEX): REAL'

 - Function: RealPart `(Z: LONGCOMPLEX): LONGREAL'
     This function returns the real part of the complex number Z.

 - Function: ImagPart `(Z: COMPLEX): REAL'

 - Function: ImagPart `(Z: LONGCOMPLEX): LONGREAL'
     This function returns the imaginary part of the complex number Z.

 - Function: add `(Z1, Z2: COMPLEX): COMPLEX'

 - Function: add `(Z1, Z2: LONGCOMPLEX): LONGCOMPLEX'
     This function returns the value of Z1 added to Z2.

 - Function: sub `(Z1, Z2: COMPLEX): COMPLEX'

 - Function: sub `(Z1, Z2: LONGCOMPLEX): LONGCOMPLEX'
     This function returns the value of Z2 subtracted from Z1.

 - Function: mul `(Z1, Z2: COMPLEX): COMPLEX'

 - Function: mul `(Z1, Z2: LONGCOMPLEX): LONGCOMPLEX'
     This function returns the value of Z1 multiplied by Z2.

 - Function: div `(Z1, Z2: COMPLEX): COMPLEX'

 - Function: div `(Z1, Z2: LONGCOMPLEX): LONGCOMPLEX'
     This function returns the value of Z1 divided by Z2.

 - Function: abs `(Z: COMPLEX): REAL'

 - Function: abs `(Z: LONGCOMPLEX): LONGREAL'
     This function returns an approximation to the length (also known
     as the absolute value, or modulus) of Z.

     *Please note:* An overflow exception may be raised in this
     computation, even when the complex number itself is well defined.

 - Function: arg `(Z: COMPLEX): REAL'

 - Function: arg `(Z: LONGCOMPLEX): LONGREAL'
     This function returns an approximation to the angle that Z
     subtends to the positive real axis in the complex plane.  The
     result will be in radians in the range `[-pi, pi]'.  If the
     modulus (`abs(X)') of Z is zero, an exception is raised.

 - Function: conj `(Z: COMPLEX): COMPLEX'

 - Function: conj `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the complex conjugate of
     Z.

 - Function: power `(BASE: COMPLEX; EXPONENT: REAL): COMPLEX'

 - Function: power `(BASE: LONGCOMPLEX; EXPONENT: LONGREAL):
          LONGCOMPLEX'
     This function returns an approximation to the value of the number
     BASE raised to the power EXPONENT.

 - Function: sqrt `(Z: COMPLEX): COMPLEX'

 - Function: sqrt `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the principal square
     root of Z.

     *Please note:* The result is the complex number with an `arg()' of
     half the value of the `arg()' of z, and whose `abs()' is the
     positive square root of the `abs()' of Z.

 - Function: exp `(Z: COMPLEX): COMPLEX'

 - Function: exp `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the mathematical
     constant `e' raised to the power of Z.

 - Function: ln `(Z: COMPLEX): COMPLEX'

 - Function: ln `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the principal value of
     the natural logarithm of Z.

 - Function: sin `(Z: COMPLEX): COMPLEX'

 - Function: sin `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the complex sine of Z.

 - Function: cos `(Z: COMPLEX): COMPLEX'

 - Function: cos `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the complex cosine of Z.

 - Function: tan `(Z: COMPLEX): COMPLEX'

 - Function: tan `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the complex tangent of Z.
     If Z is an odd multiple of `pi/2', an exception is raised.

 - Function: arcsin `(Z: COMPLEX): COMPLEX'

 - Function: arcsin `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the principal value of
     the complex arcsine of Z.

 - Function: arccos `(Z: COMPLEX): COMPLEX'

 - Function: arccos `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the complex arccosine of
     Z.

 - Function: arctan `(Z: COMPLEX): COMPLEX'

 - Function: arctan `(Z: LONGCOMPLEX): LONGCOMPLEX'
     This function returns an approximation to the complex arctangent
     of Z.

 - Function: polarToComplex `(ABS, ARG: REAL): COMPLEX'

 - Function: polarToComplex `(ABS, ARG: LONGREAL): LONGCOMPLEX'
     This function returns an approximation to the complex number with
     the specified polar coordinates.  The result will have a length of
     ABS and angle of ARG).

 - Function: scalarMult `(SCALAR: REAL; Z: COMPLEX): COMPLEX'

 - Function: scalarMult `(SCALAR: LONGREAL; Z: LONGCOMPLEX):
          LONGCOMPLEX'
     This function returns an approximation to the scalar product of
     SCALAR with Z.

 - Function: IsCMathException `(): BOOLEAN'
     This function returns `TRUE' if the current process is in the
     exceptional execution state because of the raising of the
     corresponding `ComplexMath' or `LComplexMath' exception;
     otherwise, it returns `FALSE'.


File: OOCref.info,  Node: Random Numbers,  Prev: Complex Numbers,  Up: Mathematics

Random Numbers
==============

   "Random number" generating routines, like those provided in module
`RandomNumbers', are more correctly called "pseudo-random number
generators" because they have only the appearance of randomness, and
actually exhibit a specific, repeatable pattern.  However, the generated
sequence of numbers should pass certain statistical tests *as if* it
were a truly random sequence.

   The algorithm implemented by `RandomNumbers' is "good" in the sense
that it passes many of these statistical tests, but it is not
necessarily useful in all cases.  A different algorithm might be better
suited to a particular application simply because the inherent
structure of the generated number sequence better satisfies the
application's required properties.

   Because of the deterministic quality of random number generators,
the user is required to specify an initial value, or "seed".  Sequences
generated using the same seed (and the same algorithm) will always
produce the same results.  To get a different sequence, simply use a
different seed.  A common way to generate different seeds is to
initialize using the system's clock time.  (This is not done directly
within `RandomNumbers' because then it is not possible to reproduce
results, which could cause difficulties during, say, testing and
debugging.)

   Also note that sequences *will* repeat themselves eventually.  In
this case, a sequence will start to repeat after, at most, `modulo-1'
elements, and possibly much sooner than that.

   A complete discussion of random number generating algorithms is
beyond the scope of this manual.  For more information about the
algorithm used in this module, and other random number generators,
consult the following references:

`Random number generators: good ones are hard to find'
S.K. Park and K.W. Miller
Communications of the ACM, Vol. 31, No. 10, October 1988, pp. 1192-1201

`The Art Of Computer Programming:
Volume 2, Seminumerical Algorithms, Second Edition'
Donald E. Knuth
Addison-Wesley Publishing Co., January 1981

 - Constant: modulo
     The determing parameter of the linear congruential generator being
     used by `RandomNumbers'.

 - Procedure: GetSeed `(VAR SEED: LONGINT)'
     This procedure gets the seed value currently in use by routines in
     module `RandomNumbers'.

 - Procedure: PutSeed `(SEED: LONGINT)'
     This procedure sets SEED as the new seed value for routines in
     `RandomNumbers'.  Any value for SEED is allowed, but all values
     will be mapped into the range `[1..modulo-1]'.

 - Function: RND `(RANGE: LONGINT): LONGINT'
     This function calculates a new "random" number.  RANGE has to be in
     the range `[1..modulo-1]', and the result is a number in the
     interval `[0, RANGE-1]'.

 - Function: Random `(): REAL'
     This function calculates a new "random" number.  The result is a
     number in the interval `[0, 1)'.

   *Example:*

     VAR l: LONGINT;
         r: REAL;
     
     RandomNumbers.PutSeed(314159);
     
     l := RandomNumbers.RND(100);
        => l = 19
     l := RandomNumbers.RND(10000);
        => l = 5610
     l := RandomNumbers.RND(9999999);
        => l = 6158792
     l := RandomNumbers.RND(365);
        => l = 54
     
     RandomNumbers.GetSeed(l);
        => l = 143441039
     
     r := RandomNumbers.Random();
        => r = 0.6225381
     r := RandomNumbers.Random();
        => r = 0.9990177
     r := RandomNumbers.Random();
        => r = 0.4895853
     r := RandomNumbers.Random();
        => r = 0.4605866
     
     RandomNumbers.GetSeed(l);
        => l = 989102265


File: OOCref.info,  Node: Date and Time,  Next: Oakwood Compliant Modules,  Prev: Mathematics,  Up: Top

Date and Time
*************

   This chapter describes the facilities for manipulating dates and
times, including getting and setting the date and time, and conversions
between formats.

* Menu:

* Time::                        Manipulation of time stamps and time
                                 intervals.
* JulianDay::                   Convert between day/month/year and
                                 Modified Julian Days.
* SysClock::                    Reading and setting the system clock.
* Calendar::                    Conversion between calender dates, time
                                 stamps, and date/time string formats.


File: OOCref.info,  Node: Time,  Next: JulianDay,  Up: Date and Time

Module Time
===========

   Module `Time' provides facilites for time stamp and time interval
manipulation.

   A "time stamp" represents a particular instant in time.

   A "time interval" is the duration between two instants read on the
same time scale.

   Another way to view time stamps and intervals is to consider them in
the context of a one-dimensional vector space: A time stamp is a point,
a time interval a vector.  Seen in this way, some functions perform
vector arithmetic on time intervals.

     *Please note:* Date and time modules refer to "UTC", which is
     Coordinated Universal Time (or Universal Time Coordinated).  UTC
     replaces Greenwich Mean Time (GMT) and is recommended for all
     general timekeeping applications.  UTC and GMT are effectively
     equivalent; the difference being that UTC is adjusted by an
     integral number of seconds called "leap seconds" (see
     `http://www.boulder.nist.gov/timefreq/glossary.htm' for more
     precise definitions).

     No provision is made for leap seconds in the date and time modules.

   The following constants are defined:

 - Constant: msecPerSec
     The number of milliseconds per second.

 - Constant: msecPerMin
     The number of milliseconds per minute.

 - Constant: msecPerHour
     The number of milliseconds per hour.

 - Constant: msecPerDay
     The number of milliseconds per day.

   Module `Time' declares the following types for time intervals and
time stamps:

 - Class: Interval = RECORD
     This type is used to represent a delta time measure, which can be
     used to increment a time or find the time difference between two
     times.

     The maximum number of milliseconds in an interval is the value
     `msecPerDay'.

     The fields are defined as follows:

    Field: dayInt-: `LONGINT'
          The number of days in this interval.

    Field: msecInt-: `LONGINT'
          The number of milliseconds in this interval.

   The following are operations on `Interval':

 - Procedure: InitInterval `(VAR INT: Interval; DAYS, MSECS: LONGINT)'
     This procedure is used to initialize an `Interval' INT with DAYS
     days and MSECS milliseconds.

     *Pre-condition*: MSECS is not negative.

Method: `(VAR A: Interval)' Add `(B: Interval)'
     This method computes the value of A added to B.  The result is
     assigned to A.

Method: `(VAR A: Interval)' Sub `(B: Interval)'
     This method computes the value of B subtracted from A.  The result
     is assigned to A.

   *Example:*

     VAR int1, int2: Time.Interval;
     
     Time.InitInterval(int1, 10, 0);
     
     Time.InitInterval(int2, 5, 0);
        => int2.dayInt = 5, int2.msecInt = 0
     
     int1.Add(int2);  (* == int1 = int1 + int2 *)
        => int1.dayInt = 15, int1.msecInt = 0
     
     int1.Add(int1);  (* == int1 = int1 + int1 *)
        => int1.dayInt = 30, int1.msecInt = 0
     
     int1.Sub(int2);  (* == int1 = int1 - int2 *)
        => int1.dayInt = 25, int1.msecInt = 0
     
     Time.InitInterval(int1, 0, 43200000);  (* == 12 hours *)
        => int1.dayInt = 0, int1.msecInt = 43200000
     
     int1.Add(int1);  (* 12 hrs + 12 hrs = 24 hrs == 1 day *)
        => int1.dayInt = 1, int1.msecInt = 0
     
     Time.InitInterval(int2, 0, 1800000);  (* == 30 minutes *)
        => int2.dayInt = 0, int2.msecInt = 1800000
     
     int2.Add(int2);  (* 30 mins + 30 mins = 60 mins == 1 hr *)
        => int2.dayInt = 0, int2.msecInt = 3600000
     
     int1.Sub(int2);  (* 24 hrs - 1 hr = 23 hrs == 82800000 *)
        => int1.dayInt = 0, int1.msecInt = 82800000

Method: `(VAR A: Interval)' Cmp `(B: Interval): SHORTINT'
     This method compares the values of A and B and returns the
     following result:

       If `a > b', return `1'
       If `a = b', return `0'
       If `a < b', return `-1'

Method: `(VAR A: Interval)' Scale `(B: LONGREAL)'
     This method scales the value of A by B (i.e., A multiplied by B).
     The result is assigned to A.

     *Pre-condition*: B is not negative.

Method: `(VAR A: Interval)' Fraction `(B: Interval): LONGREAL'
     This method computes the fraction B of the interval A (i.e, A
     divided by B).

     *Pre-condition*: B is not zero.

   *Example:*

     VAR int1, int2: Time.Interval;
         result: SHORTINT;
         frac: LONGREAL;
     
     Time.InitInterval(int1, 0, 82800000);  (* == 23 hours *)
        => int1.dayInt = 0, int1.msecInt = 82800000
     
     Time.InitInterval(int2, 0, 3600000);  (* == 1 hr *)
        => int2.dayInt = 0, int2.msecInt = 3600000
     
     result := int1.Cmp(int2);
        => result = 1  (* == int1 > int2 *)
     
     result := int2.Cmp(int1);
        => result = -1  (* == int2 < int1 *)
     
     result := int1.Cmp(int1);
        => result = 0  (* == int1 = int1 *)
     
     int2.Scale(23);  (* 1 hr * 23 = 23 hrs *)
        => int2.dayInt = 0, int2.msecInt = 82800002
             (* approximately equal to 23 hrs. *)
     
     int2.Scale(2);  (* 23 hrs * 2 = 46 hours *)
        => int2.dayInt = 1, int2.msecInt = 79199997
             (* approximately == 1 day and 22 hours *)
     
     frac := int2.Fraction(int1); (* 46 hrs / 23 hrs = 2 *)
        => frac = 2.00000006219615  (* approx. 2 *)
     
     frac := int1.Fraction(int2); (* 23 hrs / 46 hrs = 0.5 *)
        => frac = 4.99999984450962E-1  (* approx. 0.5 *)

 - Class: TimeStamp = RECORD
     This type represents an instant in time using a compressed
     date/time format.

     *Please note:* `TimeStamp' is in Coordinated Universal Time (UTC)
     on systems that support time zones.  Without such support, it is
     assumed that they refer to the local time zone with an unspecified
     time zone offset.

     The fields are defined as follows:

    Field: days-: `LONGINT'
          Modified Julian days since midnight 17 Nov 1858.  This
          quantity can be negative to represent dates occuring before
          day zero.

    Field: msecs-: `LONGINT'
          Milliseconds since 00:00.

   The following are operations on `TimeStamp':

 - Procedure: InitTimeStamp `(VAR T: TimeStamp; DAYS, MSECS: LONGINT)'
     This procedure is used to initialize a `TimeStamp' T with DAYS
     days and MSECS milliseconds.

     *Pre-condition*: MSECS is not negative.

Method: `(VAR A: TimeStamp)' Add `(B: Interval)'
     This method adds the interval B to the time stamp A.

Method: `(VAR A: TimeStamp)' Sub `(B: Interval)'
     This method subtracts the interval B from the time stamp A.

Method: `(VAR A: TimeStamp)' Delta `(B: TimeStamp; VAR C: Interval)'
     This method subtracts the value of time stamp B from the time stamp
     A.  The result is assigned to the interval C.

Method: `(VAR A: TimeStamp)' Cmp `(B: TimeStamp): SHORTINT'
     This method compares the values of A and B and returns the
     following result:

       If `a > b', return `1'
       If `a = b', return `0'
       If `a < b', return `-1'

   *Example:*

     VAR ts1, ts2: Time.TimeStamp;
         int1  : Time.Interval;
         result: SHORTINT;
     
     Time.InitTimeStamp(ts1, 40000, 0);
        => ts1.days = 40000, ts1.msecs = 0
             (* == midnight 24 May 1968 *)
     
     Time.InitInterval(int1, 10, 3600000);
     ts1.Add(int1);
        => ts1.days = 40010, ts1.msecs = 3600000
             (* == 1:00 3 Jun 1968 *)
     
     Time.InitInterval(int1, 5000, 21600000);
             (* == 5000 days, 6 hours *)
     ts1.Sub(int1);
        => ts1.days = 35009, ts1.msecs = 68400000
             (* == 19:00 24 Sep 1954 *)
     
     Time.InitTimeStamp(ts2, 50000, 43200000);
        => ts1.days = 50000, ts1.msecs = 43200000
             (* == noon 10 October 1995 *)
     
     ts2.Delta(ts1, int1);
        => int1.dayInt = 14990, int1.msecInt = 61200000
     
     result := ts2.Cmp(ts1);
        => result = 1
             (* == ts2 > ts1  i.e., ts2 occurs after ts1 *)

