This is Info file OOCref.info, produced by Makeinfo version 1.68 from
the input file OOCref.texinfo.

   This file documents the Optimizing Oberon-2 Compiler (OOC) and its
library.

   This is Edition 0.10 DRAFT, last updated 29 February 2000, of `The
OOC Library Reference Manual', for Version 1.5.1 or later of oo2c.

   Copyright (C) 1997-2000 Eric Nikitin Part II Copyright (C) 1998-2000
Michael van Acken

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: OOCref.info,  Node: Summary of File Constants,  Prev: Other File Operations,  Up: Files

Summary of File Constants
.........................

   For constant values that are common to all channel types (*note
Summary of Channel Constants::.), local names have been provided:

 - Constant: noLength
     A result value for `File.Length'.

 - Constant: noPosition
     A possible return value for `Reader.Pos()' or `Writer.Pos()'
     meaning that the reader or writer has no concept of a position.

   The following constant applies to the `res' field, and may be
compared to it.  (i.e., `ch.res = done' or `ch.res # done'.)

 - Constant: done
     This indicates successful completion of the last operation.

   The following values are compared against the `res.code' field of the
corresponding object (of types `Channel', `Reader', or `Writer').

   The methods `res.GetLText()' or `res.GetText()' can be used to
translate any error code into a human readable message.

 - Constant: invalidChannel
     The channel (i.e., file) isn't valid.  For example, because it
     wasn't opened in the first place or was somehow corrupted.

 - Constant: writeError
     A write error occured; usually this error happens with a writer,
     but for buffered files this may also occur during a `Flush' or a
     `Close'.

 - Constant: noRoom
     A write operation failed because there isn't any space left on the
     device.  For example, the disk is full or you exeeded your quota;
     usually this error happens with a writer, but for buffered files
     this may also occur during a `Flush' or a `Close'.

   The following constants only apply to `Reader.res.code' and
`Writer.res.code':

 - Constant: outOfRange
     `SetPos' has been called with a negative argument or it has been
     called on a rider that doesn't support positioning.

 - Constant: readAfterEnd
     A call to `ReadByte' or `ReadBytes' has tried to access a byte
     beyond the end of the file.  This means that there weren't enough
     bytes left or the read operation started at (or after) the end.

 - Constant: channelClosed
     The rider's channel (i.e., file) has been closed, preventing any
     further read or write operations.  This means there was a call to
     `File.Close()' (in which case, you probably made a programming
     error), or the channel has been otherwise closed.

 - Constant: readError
     An unspecified read error.

 - Constant: invalidFormat
     Set by a mapper (e.g., TextRiders.Reader) if the byte stream at
     the current reading position doesn't represent an object of the
     requested type.

   The following constants only apply to `File.res.code':

 - Constant: noReadAccess
     `NewReader' was called to create a reader on a file that doesn't
     allow read access.

 - Constant: noWriteAccess
     `NewWriter' was called to create a writer on a file that doesn't
     allow write access.

 - Constant: closeError
     An attempt to close the file failed.

 - Constant: noModTime
     No modification time is available for the given file.

 - Constant: noTmpName
     Creation of a temporary file failed because the system was unable
     to assign an unique name to it (closing or registering an existing
     temporary file beforehand might help in this case).

   The following values report problems when opening or modifying a
file:

 - Constant: accessDenied
     Access to the file was denied, e.g., because a file's permissions
     don't permit the requested access method, or because the given URL
     isn't publically readable.

 - Constant: isDirectory
     The `flags' argument specified write access, and the file is a
     directory.

 - Constant: tooManyFiles
     The process or the entire system has too many files open.

 - Constant: noSuchFile
     The named file in a call to `Old()' does not exist.  Or the
     directory part of a file name passed to `New()' or `Tmp()' does
     not exist.

 - Constant: directoryFull
     The directory or the file system that would contain the new file
     cannot be extended, either because there is no space left or the
     directory has a fixed upper limit.

 - Constant: readOnlyFileSystem
     The file resides on a read-only file system and it is attempted to
     create a new file or to gain write access for an existing one.

 - Constant: invalidTime
     The time passed to procedure `SetModTime' is not a valid time
     stamp; either the millisecond part isn't valid, or the time value
     is too large or too small to be mapped to the time value of the
     underlying OS.

 - Constant: notOwner
     Only the owner of a file can change its modification time.

 - Constant: anonymousFile
     A file can only be registered if a file name was passed to the
     initial call to `Tmp()'.

 - Constant: dirWriteDenied
     You need to have write permission for the directory you want to
     add a new file to.

 - Constant: fileError
     Unspecified error when opening/creating a file; this usually means
     that this module doesn't know how to interpret the error code
     delivered by the OS.

 - Constant: nameTooLong
     Either the total length of the file name or of an individual file
     name component is too large; the operating system can impose such
     limits (see PATH_MAX and NAME_MAX in /usr/include/limits.h), or
     the file system itself restricts the format of names on it.

 - Constant: notDirectory
     A file that is referenced as a directory component of the file
     name exists, but is not a directory.

 - Constant: linkLoop
     Too many symbolic links were resolved while trying to look up the
     file name; the operating system has an arbitrary limit on the
     number of symbolic links that may be resolved in looking up a
     single file name, as a primitive way to detect loops.

   The following are possible elements for the FLAGS parameter of
`New', `Old', or `Tmp'.

   *Please note*: at least one of the following flags has to be set;
otherwise you will get an "access denied" error:

 - Constant: read
     If the file cannot be opened for reading access, then it isn't
     opened at all; in this case the error code is set to
     `noReadAccess'.

 - Constant: write
     If the file cannot be opened for writing access, then it isn't
     opened at all; in this case the error code is set to
     `noWriteAccess'.

 - Constant: tryRead
     Try to open this file for reading access; if the file permissions
     don't permit reading, the file is opened nevertheless, but the
     file descriptor's attribute `readable' is set to `FALSE'.

 - Constant: tryWrite
     Try to open this file for writing access; if the file permissions
     don't permit writing, the file is opened nevertheless, but the
     file descriptor's attribute `writable' is set to `FALSE'.


File: OOCref.info,  Node: StdChannels,  Next: ProgramArgs,  Prev: Files,  Up: Channels

Module StdChannels
------------------

   Module StdChannels defines the standard I/O channels, which are
predefined channels for input (typically the keyboard) and output
(typically the computer screen).

   Standard channels do not have to be opened by a client program
because they are already open and ready for use.  Their attributes and
operations are described by the class `Channel.Channel'.

   The standard channels (`stdin', `stdout', and `stderr') should never
be closed.  You *can* close the standard channels (e.g., to detach a
program from its terminal), but `StdChannels' does not provide a way to
reopen them.  Notice that the modules `In', `Out', `Err', `OakIn', and
`OakOut' are all affected by such operations on standard channels.  If,
for example, you call `stdout.Close', then the procedures in module Out
will no longer function (unless you use `Out.SetWriter' to set another
channel).

   A fourth standard channel, `null', is also provided.

   Mappers may be attached to any of these channels to provide read and
write operations for them.  Mappers from module `TextRider' are most
often used.

   Also, be aware that modules `In', `Out', and `Err' provide simple
interfaces to the standard channels (*note Standard I/O::.).  So that,
in many cases, you may not have to use module `StdChannels' directly.

 - Read-only Variable: stdin
     The "standard input" channel, which is a predefined source of
     input for the program.  The referenced channel is read-only.

   *Example:*

     VAR stringVar: ARRAY 256 OF CHAR;
         rdr:       TextRider.Reader;
     
     rdr := TextRider.ConnectReader(StdChannels.stdin);
     rdr.ReadLine(stringVar);

 - Read-only Variable: stdout
     The "standard output" channel, which is a predefined destination
     for output from the program.  The referenced channel is write-only.

   *Example:*

     VAR wrtr: TextRider.Writer;
     
     wrtr := TextRider.ConnectWriter(StdChannels.stdout);
     wrtr.WriteString("A string to write"); wrtr.WriteLn;

 - Read-only Variable: stderr
     The "standard error" channel, which can be used for error messages
     and diagnostics issued by the program.  The referenced channel is
     write-only.

   *Example:*

     VAR wrtr: TextRider.Writer;
     
     wrtr := TextRider.ConnectWriter(StdChannels.stderr);
     wrtr.WriteString("An error has occured"); wrtr.WriteLn;

 - Read-only Variable: null
     The "null" channel, which can be used as a destination for output
     that is to be discarded.  The referenced channel is write-only.


File: OOCref.info,  Node: ProgramArgs,  Prev: StdChannels,  Up: Channels

Module ProgramArgs
------------------

   This module provides access to the command line arguments passed to
the program's invocation.  They are mapped onto a standard channel
`args', with each argument transformed into a single line of text.
Interpreting the list of arguments is usually done by applying an
instance of `TextRider.Reader' or `TextRider.Scanner' to the argument
channel.

   The number of arguments is determined by calling `args.ArgNumber()'.
If the invocation were, for example, `foo bar 42', where `foo' is the
name of the program itself, then the channel's contents would look like
this:

     foo
     bar
     42

   For the above example, `args.ArgNumber()' would return `2'; that is,
the program name is not counted by `ArgNumber' even though it is
present in `args'.

   Note that any end-of-line characters within command line arguments
are mapped to space (`20X') characters.  This ensures, that a single
argument is always mapped onto a single line of text, even if it has
embedded end-of-line characters.

   Also, be careful with settings for `TextRider.Reader' and especially
`TextRider.Scanner': end-of-line characters are treated as whitespace
by many of the read operations, which means, for a program `foo', the
reader or scanner has no way of distinguishing between

     foo 123 bar
     for "123 bar"

   You would normally consider the first invocation as having two
arguments, and the second as having one; which is also how ProgramArgs
would interpret them.  For `foo 123 bar', `args' would contain

     foo
     123
     bar

   whereas, for `foo "123 bar"', `args' would contain

     foo
     123 bar

   But a text reader or scanner, if set to treat end-of-line as
whitespace, would treat both of these invocations as equivalent.

     *Please note*: In cases where separate arguments need to be
     considered as a whole, the reader method `ReadLine' should be used.
     Unlike other read operations, such as`ReadInt' or
     `ReadIdentifier', leading whitespace is not skipped and, after
     completion, the reading position is just behind the end-of-line
     character.

     So `ReadLine' should be used to read, for example, file name
     arguments because operating systems like Unix typically allow
     arbitrary characters in file names, including blanks and control
     codes.

   Module `ProgramArgs' provides local equivalents for the following
constants from module `Channels': `done', `outOfRange', `readAfterEnd',
`channelClosed', `noWriteAccess', and `noModTime'.

 - Class: Channel = POINTER TO ChannelDesc
     This class is derived from the abstract base channel class.  In
     addition to its inherited fields and methods (*note Abstract Class
     Channel::.), the class provides the following method:

    Method: `(VAR CH: Channel)' ArgNumber `(): LONGINT'
          Returns the number of command line arguments (excluding the
          program name itself) passed to the program.

 - Read-only Variable: args
     The predefined "program arguments" channel.  The referenced
     channel is read-only.

   As a further example, suppose a program `foo' required exactly two
(positional) command line arguments.  The first is an integer value and
the second is an identifier.  Also, suppose that all of the following
invocations are to be considered equivalent:

     foo 123 bar
     foo +123 bar
     foo "  +123" " bar"

   Note that, the following module would *not* consider `foo 123 " bar
"' or `foo 123+ bar' to be equivalent to the above invocations.

   *Example:*

     VAR r: TextRider.Reader;
         str: ARRAY 256 OF CHAR;
         int: LONGINT;
     
       r := TextRider.ConnectReader(ProgramArgs.args);
       IF r = NIL THEN
          (* Error processing: failed to connect to `args' *)
       END;
     
       IF ProgramArgs.args.ArgNumber() # 2 THEN
          (* Error processing: wrong number of arguments *)
       END;
     
       (* skip past the line containing the program name `foo' *)
       r.ReadLn;
     
       r.ReadLInt(int);
       IF r.res # TextRider.done THEN
          (* Error processing: can't read an integer *)
       ELSIF ~r.Eol() THEN
          (* Error processing: this argument has other stuff after
             the integer just read *)
       END;
     
       r.ReadLn; (* skip to the next line *)
     
       r.ReadIdentifier(str);
       IF r.res # TextRider.done THEN
          (* Error processing: can't read an identifier *)
       ELSIF ~r.Eol() THEN
          (* Error processing: extra stuff after the identifier *)
       END;


File: OOCref.info,  Node: Messages,  Next: Standard Mappers,  Prev: Channels,  Up: I/O Subsystem

Messages
========

   Module `Msg' provides a framework for messages, which are used as a
level of indirection between simple error codes and human readable error
messages.  Unlike numeric error codes, an instance of `Msg' carries its
own interpretation context.  Using this context, plus the error code
stored in the message, and possibly additional data, the message can be
converted into a description.  The additional data can be text
fragments, numbers, or other messages, and it can be inserted anywhere
into the message's text.  There is no need to determine the message
text at the place the message is created.  A message can be converted
to text anywhere in the program.

   This module actually combines several concepts: messages, message
attributes, message contexts, and message lists.  Although this may
seem a bit complicated, the actual mechanism is very simple.

   A "message" is an object that can be converted to human readable
text and presented to a program's user.  Within the OOC Library,
messages are used to store errors in the I/O modules.  Another example
is an XML parser, which uses messages to create an error list when
parsing an XML document.

   "Contexts" and "attributes" are primarily of interest for modules
that generate messages.  These determine the content of the message,
and how it can be translated into readable text.  A typical user will
mostly be in the position of message consumer, and will be handed
filled in message objects.  For a user, the typical operation will be
to convert a message into descriptive text (see methods
`Message.GetText()' and `Message.GetLText()').

   "Message lists" are a convenience feature for modules like parsers,
which normally do not abort after a single error message.  Usually,
they try to continue their work after an error, looking for more
problems and possibly emitting more error messages.  Using message
lists, errors can be collected together (e.g., within a compiler) to be
presented to the user in a single batch.

Messages
--------

 - Class: Msg = POINTER TO MsgDesc
     A message's type is uniquely identified by its context and its
     code.  Using these two attributes, a message can be converted to
     text.  The text may contain placeholders, which are filled by the
     textual representation of attribute values associated with the
     message.
    Field: nextMsg-: `Msg'

    Field: prevMsg-: `Msg'
          These two fields are initialized to `NIL', and are used by
          `MsgList'.

    Field: code-: `Code'

    Field: context-: `Context'

    Field: attribList-: `Attribute'
          This list of attributes is sorted by name.  Follow
          `Attribute.nextAttrib' to traverse the list.

   The following function is a constructor for a message object:

 - Function: New `(CONTEXT: Context; CODE: Code): Msg'
     This function creates and returns a new message object for the
     given context, using the specified message code.  The message's
     attribute list is empty.

   Users of messages will be most interested in the following methods,
which are used to retrieve the textual representation of a message:

Method: `(MSG: Msg)' GetLText `(VAR TEXT: LString)'
     This method converts a message into a text string.  The basic
     format of the string is determined by calling
     `msg.context.GetTemplate'.  Then the attributes are inserted into
     the template string; the placeholder string `${foo}' is replaced
     with the textual representation of each attribute (see
     `Context.GetTemplate').

     *Pre-condition*: `LEN(text)<2^15'

     *Please note:* Behaviour is undefined if replacement text of an
     attribute contains an attribute reference.

Method: `(MSG: Msg)' GetText `(VAR TEXT: String)'
     This method operates just like `GetLText', but the message text is
     truncated to ISO-Latin-1 characters.  All characters that are not
     part of ISO-Latin-1 are mapped to question marks `?'.

   *Example:*

     VAR r: TextRider.Reader;
         f: Files.File;
         str: ARRAY 256 OF CHAR;
         res: Files.Result;     (* `Result' is an alias for `Msg.Msg'. *)
     
       f := Files.Old("Sample.txt", {Files.read}, res);
       IF (f = NIL) THEN
          res.GetText(str);
          Err.String(str); Err.Ln;
       ELSE
          r := TextRider.ConnectReader(f);
          IF (r # NIL) THEN
             r.ReadLine(str);	    (* Read the lines of a file. *)
             WHILE r.res=Files.done DO
                Out.String(str); Out.Ln; (* And output them to the screen. *)
                r.ReadLine(str);
             END;
             (*  Check to see if it stopped reading because it reached
              *  end-of-file.  If not, then print the error string.
              *)
             IF (r.res.code#Files.readAfterEnd) THEN
                r.res.GetText(str);
                Err.String(str); Err.Ln;
             END;
          END;
       END;

   A programmer who is creating a library module can use the following
methods to manage the attributes of a message:

Method: `(MSG: Msg)' GetAttribute `(NAME: String): Attribute'
     This method returns the attribute NAME of the message object.  If
     no such attribute exists, the value `NIL' is returned.

Method: `(MSG: Msg)' SetAttribute `(ATTR: Attribute)'
     This method appends an attribute to the message's attribute list.
     If an attribute of the same name exists already, it is replaced by
     the new one.

     *Pre-condition*: `Length(attr.name^)<=sizeAttrName' and ATTR has
     not been attached to any other message.

Method: `(MSG: Msg)' SetIntAttrib `(NAME: String; VALUE: LONGINT)'
     *Pre-condition*: `Length(name)<=sizeAttrName'

   *Example:*

     VAR
       lineVal, colVal: LONGINT;
       attrib1, attrib2: Msg.Attribute;
     
     msg.SetIntAttrib ("line", lineVal);
     msg.SetIntAttrib ("column", colVal);
     
     ...
     
     attrib1 := GetAttribute("line");
     attrib2 := GetAttribute("column");

Method: `(MSG: Msg)' SetStringAttrib `(NAME: String; VALUE: StringPtr)'
     *Pre-condition*: `Length(name)<=sizeAttrName'

Method: `(MSG: Msg)' SetLStringAttrib `(NAME: String; VALUE: LStringPtr)'
     *Pre-condition*: `Length(name)<=sizeAttrName'

Method: `(MSG: Msg)' SetMsgAttrib `(NAME: String; VALUE: Msg)'
     *Pre-condition*: `Length(name)<=sizeAttrName'

Contexts and Attributes
-----------------------

   When writing a library module (or perhaps a set of related library
modules), a `Context' is defined, which may specify message formats and
handle generation of messages.  Specific `Attributes' that directly
relate to a `Context', and its related messages, are defined to go
along with that `Context'.

   The basic steps are
   * Declare a subclass of `Context'.

   * Define a variable of that `Context' class (and be sure to
     initialize it in the module body).

   * (Optional) Define attributes that are applicable to the context.

   * Override the `GetTemplate' method so that it supplies messages in
     the desired format (using `GetAttribute' to retrieve attribute
     information, if necessary).

   * (Optional) Write a message generating function to produce
     appropriate message objects.

   The following is an example showing how a `Context' can be set up.
(In this case, for a command line parser).  Note that use of
`Attributes' is not required (and not shown in this example), and that
this example has only a single error message.

     MODULE CmdLine;
     
     IMPORT Msg;
     
     (* Context and template infrastructure *)
     CONST
       connectFailed = 1;
     
     TYPE
       ErrorContext = POINTER TO ErrorContextDesc;
       ErrorContextDesc = RECORD
         (Msg.ContextDesc)
       END;
     
     VAR
       cmdLineContext: ErrorContext;
     
     PROCEDURE (context: ErrorContext) GetTemplate* (msg: Msg.Msg;
                                                     VAR templ: Msg.LString);
       VAR
         t: ARRAY 128 OF Msg.LChar;
       BEGIN
         CASE msg. code OF
         | connectFailed:
           t := "Failed to connect reader to program arguments"
         END;
         COPY (t, templ)
       END GetTemplate;
     
     
     
     PROCEDURE Error (code: Msg.Code): Msg.Msg;
     (* Create error message for context `cmdLineContext', using the error
        code `code'.  *)
       VAR
         err: Msg.Msg;
       BEGIN
         err := Msg.New (cmdLineContext, code);
         RETURN err
       END Error;
     
     
     BEGIN
       (* initialize error context *)
       NEW (cmdLineContext);
       Msg.InitContext (cmdLineContext, "CmdLine")
     END CmdLine.

 - Class: Context = POINTER TO ContextDesc
     Instances of this class describe the context under which messages
     are converted into their textual representation.  Together, a
     message's context and its code identify the message type.

    Field: id-: `StringPtr'
          As a debugging aid, this field is usually filled with an
          string that identifies the module that created this context
          instance (see procedure `InitContext').

   The following is an initialization procedure for `Context's:

 - Procedure: InitContext `(CONTEXT: Context; ID: String)'
     This procedure intializes an instance of `Context'.  The string
     argument ID should describe the message context to the programmer.
     It should not appear in output generated for a program's user, or
     at least, it should not be necessary for a user to interpret this
     string to understand the message.  Generally, it is a good idea to
     use the module name of the context variable for the identifier.
     If this is not sufficient to identify the variable, add the
     variable name to the string.

Method: `(CONTEXT: Context)' GetTemplate `(MSG: Msg; VAR TEMPL: LString)'
     This method returns a template string for the message MSG.  The
     template is used as the basis for the human readable string
     returned by `GetText'.  Typically, the string is derived from the
     message code, and it contains attribute references.  Instead of
     the reference `${foo}', the procedure `GetText' (see below) will
     insert the textual representation of the attribute with the name
     `foo'.  The special reference `${MSG_CONTEXT}' is replaced by the
     value of `context.id', and `${MSG_CODE}' with `msg.code'.

     The default implementation returns this string:
          MSG_CONTEXT: ${MSG_CONTEXT}
          MSG_CODE: ${MSG_CODE}
          attribute_name: ${attribute_name}

     The last item is repeated for every attribute name.  The lines are
     separated by `CharClass.eol'.

     *Pre-condition*: `msg # NIL'

   *Example:*

     PROCEDURE (context: aContext) GetTemplate* (msg: Msg.Msg;
                                                 VAR templ: Msg.LString);
     VAR
        t: ARRAY 128 OF Msg.LChar;
     BEGIN
        CASE msg. code OF
     
        ...  (* set the value of `t' with appropriate message *)
     
        END;
        COPY (t, templ);
        (* then append the line and column numbers ---
         * note that attribute values are later substituted by
         * `Msg.GetLText' or `Msg.GetText'.
         *)
        LongStrings.Append (" line=${line}, column=${column}", templ);
     END GetTemplate;

Attributes
..........

 - Constant: sizeAttrName
     Maximum length of the attribute name for `InitAttribute',
     `NewIntAttrib', `NewStringAttrib', `NewLStringAttrib', or
     `NewMsgAttrib'.

 - Class: Attribute = POINTER TO AttributeDesc
     An attribute is a (name, value) tuple, which can be associated
     with a message.  When a message is tranlated into its readable
     version through the `GetText' function, the value part of each
     attribute can be converted to some textual representation, and
     then inserted into the message's text.  Within a message, an
     attribute is uniquely identified by its name.
    Field: nextAttrib-: `Attribute'

    Field: name-: `StringPtr'
          The name of an `Attribute' is restricted to `sizeAttrName'
          characters.

   The following is an initialization procedure for `Attribute's:

 - Procedure: InitAttribute `(ATTR: Attribute; NAME: String)'
     This procedure initializes an attribute object and sets its NAME.

Method: `(ATTR: Attribute)' ReplacementText `(VAR TEXT: LString)'
     This method converts the attribute value into some textual
     representation.  The length of the resulting string must not exceed
     `sizeAttrReplacement' characters.  Note that `GetLText()' calls
     this procedure with a text buffer of `sizeAttrReplacement+1' bytes.

   The following are default implementations for some commonly used
message attributes and their corresponding constructors and
`ReplacementText' methods:

 - Class: IntAttribute = POINTER TO IntAttributeDesc
    Field: int-: `LONGINT'

 - Function: NewIntAttrib `(NAME: String; VALUE: LONGINT): IntAttribute'
     This function creates and returns a new attribute (`IntAttribute')
     object.

     *Pre-condition*: `Length(name)<=sizeAttrName'

Method: `(ATTR: IntAttribute)' ReplacementText `(VAR TEXT: LString)'
 - Class: StringAttribute = POINTER TO StringAttributeDesc
    Field: string-: `StringPtr'

 - Function: NewStringAttrib `(NAME: String; VALUE: StringPtr):
          StringAttribute'
     This function creates and returns a new attribute
     (`StringAttribute') object.

     *Pre-condition*: `Length(name)<=sizeAttrName'

Method: `(ATTR: StringAttribute)' ReplacementText `(VAR TEXT: LString)'
 - Class: LStringAttribute = POINTER TO LStringAttributeDesc
    Field: string-: `LStringPtr'

 - Function: NewLStringAttrib `(NAME: String; VALUE: LStringPtr):
          LStringAttribute'
     This function creates and returns a new attribute
     (`LStringAttribute') object.

     *Pre-condition*: `Length(name)<=sizeAttrName'

Method: `(ATTR: LStringAttribute)' ReplacementText `(VAR TEXT: LString)'
 - Class: MsgAttribute = POINTER TO MsgAttributeDesc

Field: msg-: `Msg'
 - Function: NewMsgAttrib `(NAME: String; VALUE: Msg): MsgAttribute'
     This function creates and returns a new attribute (`MsgAttribute')
     object.

     *Pre-condition*: `Length(name)<=sizeAttrName'

Method: `(ATTR: MsgAttribute)' ReplacementText `(VAR TEXT: LString)'
Message Lists
-------------

 - Class: MsgList = POINTER TO MsgListDesc
    Field: msgCount-: `LONGINT'
          The number of messages on the list.

    Field: msgList-: `Msg'
          The messages of the list can be traversed using the fields
          `Msg.nextMsg' and `Msg.prevMsg'.

   The following are for construction and initialization of `MsgList's:

 - Procedure: InitMsgList `(L: MsgList)'
     This procedure initializes a message list object.

 - Function: NewMsgList `(): MsgList'
     This function creates and returns a new message list object.

   The following methods are used to add messages to a message list:

Method: `(L: MsgList)' Append `(MSG: Msg)'
     Appends the message MSG to the list L.

     *Pre-condition*: MSG is not part of another message list.

Method: `(L: MsgList)' AppendList `(SOURCE: MsgList)'
     Appends the messages of list SOURCE to L.  Afterwards, SOURCE is
     an empty list, and the elements of SOURCE can be found at the end
     of the list L.


File: OOCref.info,  Node: Standard Mappers,  Next: Standard I/O,  Prev: Messages,  Up: I/O Subsystem

Standard Mappers
================

   Mappers are high-level riders, which are used to translate between a
sequence of data items and an uninterpreted sequence of bytes (*note
Riders and Mappers::.).  Thus, the reader and writer types in
BinaryRider and TextRider are considered mappers.

   The "standard mappers", defined in this section, use the basic riders
associated with a particular channel type for reading and writing bytes.
You'll notice that there are very few error code constants defined
within either of these modules; error codes are dependant on the
channel being read, and so you'll have to use the constant values for
readers and writers that are declared within each particular channel
module.

   Because OOC has both `CHAR' and `LONGCHAR' character types, mappers
for textual data have been set up as a class hierarchy, with base
classes in module `Rider' from which all other text mappers derive.

* Menu:

* Text Mappers::                Textual input from and output to channels.
* BinaryRider::                 Binary input from and output to channels.


File: OOCref.info,  Node: Text Mappers,  Next: BinaryRider,  Up: Standard Mappers

Text Mappers
------------

   The text mapper modules (`Rider', `LongRider', `TextRider', and
`UnicodeRider') provide facilities for reading and writing values in
"text format".  Text format is delimited, or otherwise formatted,
sequences of character values that can be interpreted as words, numbers,
symbols, and so forth.  This corresponds to the way human beings read
text, or perhaps how an Oberon-2 source file is parsed by a compiler.
Data in text format are generally refered to simply as "text".

   Text can usually be interpreted in a limited number of ways.  For
example, the number `2' can be read as an `INTEGER' value or as a
`REAL'.  It could be an element of a `SET', or perhaps even be part of
an identifier such as `oo2c'.  The interpretation is based on context
and the format of the characters rather than as a fixed number of bytes.

   Because the corresponding classes from the text mapper modules
provide related facilities, they form a class hierarchy as follows:

                 Rider [ABSTRACT]
                 /    \
               /        \
             /            \
        TextRider        LongRider [ABSTRACT]
                              |
                              |
                              |
                         UnicodeRider

* Menu:

* Rider::                       Abstract classes for text based I/0.
* LongRider::                   Abstract classes with LONGCHAR support.
* TextRider::                   ISO-Latin-1 (CHAR) text based I/0.
* UnicodeRider::                Unicode (LONGCHAR) text based I/0.


File: OOCref.info,  Node: Rider,  Next: LongRider,  Up: Text Mappers

Module Rider
------------

   Module `Rider' encapsulates the base classes for all other text
mapper classes.  These base classes (`Reader', `Writer', and `Scanner')
are abstract classes that define the interface elements required for
concrete classes derived from them.

   See the concrete text mapper classes for more detail and examples of
usage (*Note TextRider:: and *Note UnicodeRider::).

* Menu:

* Class Reader (Rider)::        Abstract class defining text readers.
* Class Writer (Rider)::        Abstract class defining text writers.
* Class Scanner (Rider)::       Abstract class defining text scanners.


File: OOCref.info,  Node: Class Reader (Rider),  Next: Class Writer (Rider),  Up: Rider

Class Reader (Rider)
....................

 - Constant: maxLengthEol
     The maximum number of characters allowed in `Reader.eol'.

 - Abstract Class: Reader = POINTER TO ReaderDesc
     This class provides facilities for reading various kinds of text.
     Note that this type does not inherit properties from any basic
     reader type; rather it uses the basic reader type associated with
     the channel it is attached to.

     Also note that, after any failed read operation, all further
     attempts to read will be ignored until the error is cleared using
     `ClearError'.

     *Note Class Reader (TextRider)::, for examples of usage.

    Field: opt-: `SET'
          The current read options setting for the reader.

    Field: res-: `Msg.Msg'
          This field indicates the status of the last read operation
          (e.g., `ReadLine', `ReadInt', `SetPos', etc.).

          Error codes (for `res.code') are highly dependent on the
          channel being read, and therefore on the basic riders
          provided by that channel, so you must look at the result
          codes for a particular channel's reader type (e.g.,
          `Files.Reader' error codes).  See the various channel types
          for details of these error codes (i.e., *Note Files::, *Note
          StdChannels::, or *Note ProgramArgs::).

          If `res#done', use either `res.GetLText()' or `res.GetText()'
          to get a plain text error description corresponding to the
          error code.

    Field: base-: `Channel.Channel'
          This field refers to the channel the reader is connected to.

     The following fields determine how the reader interprets
     end-of-line markers.  Note that the end-of-line marker may contain
     the character `0X', which means its length must be stored in a
     separate field.  The `eol' marker cannot be empty, and all
     characters must be an ASCII code in the range `00X..1FX'.

    Field: eol-: `ARRAY maxLengthEol OF CHAR'
          The character sequence that represents an end-of-line marker.
          Note that this is a character array, *not* a string (i.e.,
          it may contain the character `0X').

    Field: eolLen-: `INTEGER'
          The number of characters in `eol'.  The default value for
          this is `-1', which means that end-of-line is auto detected
          (see `SetEol' below).  Otherwise, this value is in the range
          `1 <= eolLen <= maxLengthEol'.

   The following methods can be used to check the status of a reader
or, in some cases, change its state.  Some methods are fully described
in the abstract reader section (*note Abstract Class Reader::.), so
only brief descriptions of those are given here.

Method: `(R: Reader)' Available `() : LONGINT'
     Returns the number of bytes available for the next read operation.

Method: `(R: Reader)' ClearError
     Clears error conditions on the reader R, re-enabling further read
     operations.

Method: `(R: Reader)' Eol `(): BOOLEAN'
     This method returns `TRUE' if the reader is currently positioned
     at an end-of-line marker (see `SetEol' below).  This will also
     return `TRUE' if `R.res # done'.  Otherwise, `FALSE' is returned.

Method: `(R: Reader)' Pos `(): LONGINT'
     Returns the current reading position associated with the reader R
     in channel `R.base'.

Method: `(R: Reader)' SetEol `(MARKER: ARRAY OF CHAR; MARKERLEN: INTEGER)'
     This method sets the end-of-line marker; that is, what
     character(s) is used to mark the end of a line.  If the passed
     string MARKER does not fit into the field `eol', or if it contains
     a character >= ` ', then `R.res.code' is set to `invalidFormat'.

     A marker length `markerLen=-1' enables auto detection of the
     end-of-line convention used by the channel.  For auto detection to
     work, the channel is required to use one of the following `eol'
     markers:

    `LF'
          used by Unix

    `CR'
          used by MacOS

    `CR/LF'
          used by MS-DOS and Windows

     *Please note:* `ReadChar' is unaffected by the current `eol'
     setting.  That is, if the end-of-line marker consists of more than
     one character (like `CR/LF'), each character is read separately.
     All other read operations view an end-of-line marker at an atomic
     entity when the channel is read sequentially.

     If auto detection is enabled, and the `eol' convention of the file
     is `CR/LF', then the first end-of-line marker is not skipped
     completely when reached by the reader (`R.Pos()' is at the `LF').
     This is transparent to all reading procedures except `ReadChar' and
     `Pos'; the `LF' will be skipped automatically on the next read.
     This positioning inconsistency only applies for the very first
     `eol' encountered.

     *Pre-condition*: All of the following apply:
       1. `r.res = done', and

       2. `(markerLen = -1) OR (1 <= markerLen < LEN (marker))', and

       3. `markerLen <= maxLengthEol', and

       4. for all `i': `marker[i] < 20X'

Method: `(R: Reader)' SetOpts `(OPTS: SET)'
     This method is used to set the reader options `R.opt'.

Method: `(R: Reader)' SetPos `(NEWPOS: LONGINT)'
     Sets the reading position to NEWPOS.

   The following methods read a value of the given type from the current
position of the reader.  Most read operations skip leading whitespace
before reading a token; there are only three methods that do not skip
whitespace: `ReadChar', `ReadLn', and `ReadLine'.

   When attempting to read, and if the value is not properly formatted
for its type, `r.res.code' is set to `invalidFormat'.  The reader
remains positioned at the character which caused the `invalidFormat'
error, but further reading can not take place until the error is
cleared.

   If a number, or potential set element, is properly formatted, but
has a value that is out of range of the target type, then a
`valueOutOfRange' error occurs.  In this case, the reader is positioned
*after* the last character that was read.  Again, further reading can
not take place until the error is cleared.

   A `valueOutOfRange' error also occurs for methods reading into an
`ARRAY OF CHAR' (i.e., `ReadLine', `ReadIdentifier', and `ReadString')
if the character array is not large enough to hold the entire input.

   Otherwise, for any operation attempting to read when there are no
characters left to be read, a read-after-end error occurs and
`Reader.res.code' is set to `readAfterEnd'.

   In any case, whenever an error occurs, it is safest to assume that
*no* value has been read.  That is, the variable being read into is
left with an undefined value.

   All further calls of these read methods will be ignored if
`R.res#done'.  That is, no new characters will be read if an error has
occurred previously.

Method: `(R: Reader)' ReadBool `(VAR BOOL: BOOLEAN)'
     Reads in an identifier (see `ReadIdentifier' below), and if it is
     either of the tokens `TRUE' or `FALSE', it is converted to a
     `BOOLEAN' value.  If this method encounters any other token, an
     `invalidFormat' error occurs and the value of BOOL is undefined.

Method: `(R: Reader)' ReadChar `(VAR CH: CHAR)'
     Reads in a single character value and places it in CH.

Method: `(R: Reader)' ReadHex `(VAR LINT: LONGINT)'
     Reads in characters in the form of an unsigned hexadecimal number
     and converts them to a `LONGINT' value.

     The first character must be a decimal digit (i.e., `0..9') and
     subsequent characters must be valid hexadecimal digits (i.e.,
     `0..9' or `A..F').  If the first non-whitespace character is not a
     digit, then an `invalidFormat' error occurs.

     If the input is properly formatted as an unsigned hex number, but
     the value is out of range for a `LONGINT', then a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of LINT is undefined.

     *Please note:* Because `LONGINT' values are signed, hex numbers in
     the range `80000000H..FFFFFFFFH' are interpreted as negative
     `LONGINT' values.

Method: `(R: Reader)' ReadIdentifier `(VAR S: ARRAY OF CHAR)'
     Reads an Oberon-2 style identifier into S.  An "identifier" is a
     sequence of letters and digits, which must begin with a letter.

     Sequences not beginning with a letter produce an `invalidFormat'
     error.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.

Method: `(R: Reader)' ReadInt `(VAR INT: INTEGER)'
     Reads in characters in the form of a signed whole number and
     converts them to an `INTEGER' value.

     If the first character is not a digit, a "`+'" sign, or a "`-'"
     sign, then an `invalidFormat' error occurs.

     If the input is properly formatted as a signed whole number, but
     the value is out of range for an `INTEGER', then a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of INT is undefined.

Method: `(R: Reader)' ReadLInt `(VAR LINT: LONGINT)'
     This method provides the same facility as `ReadInt', except that it
     deals with `LONGINT' values.

Method: `(R: Reader)' ReadSInt `(VAR SINT: SHORTINT)'
     This method provides the same facility as `ReadInt', except that it
     deals with `SHORTINT' values.

Method: `(R: Reader)' ReadLine `(VAR S: ARRAY OF CHAR)'
     Reads a sequence of characters into S; reading continues until an
     end-of-line character is encountered, the array S is full, or R
     reaches the end of the channel.  The end-of-line character is
     discarded and S is always terminated with `0X'.

     If R is already positioned at an end-of-line character, S returns
     as an empty string.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs; S returns with the sequence of
     characters that have been read so far (terminated by `0X').

     If R has already reached the end of the channel (i.e., there are no
     more characters left to read), a `readAfterEnd' error occurs and S
     returns as an empty string.

Method: `(R: Reader)' ReadLn
     This method reads and discards all characters up to and including
     the next end-of-line character.  If the end of the channel is
     reached before encountering an end-of-line character, a
     `readAfterEnd' error occurs.

Method: `(R: Reader)' ReadString `(VAR S: ARRAY OF CHAR)'
     Reads in a sequence of characters enclosed in single (`'') or
     double (`"') quote marks.  The opening quote must be the same as
     the closing quote and must not occur within the string.

     Characters will be read until the terminating quote mark is
     encountered, an invalid character is read (end-of-line is always
     considered invalid), there are no more characters available in the
     channel, or the string S is full.  S is always terminated with
     `0X'.

     Unquoted strings produce an `invalidFormat' error.  Strings with no
     terminating quote mark also result in an `invalidFormat' error.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.

Method: `(R: Reader)' ReadReal `(VAR REAL: REAL)'
     Reads in characters in the form of a signed fixed or
     floating-point number and converts them to a `REAL' value.

     If the first character is not a digit, a "`+'" sign, or a "`-'"
     sign, then an `invalidFormat' error occurs.

     If the input is properly formatted as a signed fixed or
     floating-point number, but the value is out of range for a `REAL',
     then a `valueOutOfRange' error occurs.

     Upon encountering an error, the value of REAL is undefined.

Method: `(R: Reader)' ReadLReal `(VAR LREAL: LONGREAL)'
     This method provides the same facility as `ReadReal', except that
     it deals with `LONGREAL' values.

Method: `(R: Reader)' ReadSet `(VAR S: SET)'
     Reads in characters in the form of a set constructor and converts
     them to a `SET'.

     If the sequence of characters does not form a valid set
     constructor, then an `invalidFormat' error occurs.

     If the input is properly formatted as a set constructor, but a set
     element has a value out of the range `0..MAX(SET)', then a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.

