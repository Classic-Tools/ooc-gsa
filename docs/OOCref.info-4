This is Info file OOCref.info, produced by Makeinfo version 1.68 from
the input file OOCref.texinfo.

   This file documents the Optimizing Oberon-2 Compiler (OOC) and its
library.

   This is Edition 0.09 DRAFT, last updated 9 July 1999, of `The OOC
Library Reference Manual', for Version 1.4.5 or later of oo2c.

   Copyright (C) 1997-1999 Eric Nikitin Part II Copyright (C) 1998,
1999 Michael van Acken

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: OOCref.info,  Node: Other File Operations,  Next: Summary of File Constants,  Prev: File Locators,  Up: Files

Other File Operations
.....................

   It isn't always desirable to have to open a file before performing
certain operations on it.  You may not be interested in a file's
contents; but rather some property of the file itself (for instance,
does the named file even exist).  As such, module Files provides some
free-standing procedures:

 - Procedure: SetModTime `(VAR FILE: ARRAY OF CHAR;  VAR MTIME:
          Time.TimeStamp; VAR RES: INTEGER)'
     Sets the modification time of the given file to MTIME.  On success
     RES will contain `done', otherwise an error code that'll indicate
     the problem.

     *Please note*: under Unix this procedure will also change the
     access time to the value of MTIME.

 - Procedure: GetModTime `(VAR FILE: ARRAY OF CHAR;  VAR MTIME:
          Time.TimeStamp; VAR RES: INTEGER)'
     Gets the modification time of the given file to MTIME.  On success
     RES will contain `done', otherwise an error code indicating the
     problem.

 - Function: Exists `(VAR FILE: ARRAY OF CHAR): BOOLEAN'
     Returns `TRUE' if file FILE exists, `FALSE' otherwise.  This
     procedure may be changed in future revisions to give more useful
     information on failure.

 - Procedure: ErrorDescr `(VAR RES: INTEGER; VAR DESCR: ARRAY OF CHAR)'
     Translates this module's error codes into strings.  The string
     starts with a capital letter and does not include any termination
     punctuation.  DESCR should be large enough to hold a multi-line
     message (256 characters should suffice).  If `RES=done', then
     DESCR is assigned the empty string.

     *Please note*: This procedure should only be used to determine the
     result code of a failed attempt to create a new instance of a file
     (i.e., whenever one of the functions `New()', `Old()', or `Tmp()'
     returned `NIL').  You should use the type-bound `ErrorDescr'
     procedures for all other situations.

   *Example:*

     (* Attempting to open a "read-only" file for writing *)
     
     f := Files.Old ("example.dat", {Files.write}, res);
        => res = accessDenied
     Files.ErrorDescr (res, str);
        => str = "Failed to open file with requested access rights"


File: OOCref.info,  Node: Summary of File Constants,  Prev: Other File Operations,  Up: Files

Summary of File Constants
.........................

   For constant values that are common to all channel types (*note
Summary of Channel Constants::.), local names have been provided:

 - Constant: noLength
     A result value for `File.Length'.

 - Constant: noPosition
     A possible return value for `Reader.Pos()' or `Writer.Pos()'
     meaning that the reader or writer has no concept of a position.

   The following values may appear in the `res' field of `File',
`Reader', or `Writer':

 - Constant: done
     This indicates successful completion of the last operation.

 - Constant: invalidChannel
     The channel (i.e., file) isn't valid.  For example, because it
     wasn't opened in the first place or was somehow corrupted.

 - Constant: writeError
     A write error occured; usually this error happens with a writer,
     but for buffered files this may also occur during a `Flush' or a
     `Close'.

 - Constant: noRoom
     A write operation failed because there isn't any space left on the
     device.  For example, the disk is full or you exeeded your quota;
     usually this error happens with a writer, but for buffered files
     this may also occur during a `Flush' or a `Close'.

   The following constants only apply to `Reader.res' and `Writer.res':

 - Constant: outOfRange
     `SetPos' has been called with a negative argument or it has been
     called on a rider that doesn't support positioning.

 - Constant: readAfterEnd
     A call to `ReadByte' or `ReadBytes' has tried to access a byte
     beyond the end of the file.  This means that there weren't enough
     bytes left or the read operation started at (or after) the end.

 - Constant: channelClosed
     The rider's channel (i.e., file) has been closed, preventing any
     further read or write operations.  This means there was a call to
     `File.Close()' (in which case, you probably made a programming
     error), or the channel has been otherwise closed.

 - Constant: readError
     An unspecified read error.

 - Constant: invalidFormat
     Set by a mapper (e.g., TextRiders.Reader) if the byte stream at
     the current reading position doesn't represent an object of the
     requested type.

   The following constants only apply to `File.res':

 - Constant: noReadAccess
     `NewReader' was called to create a reader on a file that doesn't
     allow read access.

 - Constant: noWriteAccess
     `NewWriter' was called to create a writer on a file that doesn't
     allow write access.

 - Constant: closeError
     An attempt to close the file failed.

 - Constant: noModTime
     No modification time is available for the given file.

 - Constant: noTmpName
     Creation of a temporary file failed because the system was unable
     to assign an unique name to it (closing or registering an existing
     temporary file beforehand might help in this case).

   The following values report problems when opening or modifying a
file:

 - Constant: accessDenied
     Access to the file was denied, e.g., because a file's permissions
     don't permit the requested access method, or because the given URL
     isn't publically readable.

 - Constant: isDirectory
     The `flags' argument specified write access, and the file is a
     directory.

 - Constant: tooManyFiles
     The process or the entire system has too many files open.

 - Constant: noSuchFile
     The named file in a call to `Old()' does not exist.  Or the
     directory part of a file name passed to `New()' or `Tmp()' does
     not exist.

 - Constant: directoryFull
     The directory or the file system that would contain the new file
     cannot be extended, either because there is no space left or the
     directory has a fixed upper limit.

 - Constant: readOnlyFileSystem
     The file resides on a read-only file system and it is attempted to
     create a new file or to gain write access for an existing one.

 - Constant: invalidTime
     The time passed to procedure `SetModTime' is not a valid time
     stamp; either the millisecond part isn't valid, or the time value
     is too large or too small to be mapped to the time value of the
     underlying OS.

 - Constant: notOwner
     Only the owner of a file can change its modification time.

 - Constant: anonymousFile
     A file can only be registered if a file name was passed to the
     initial call to `Tmp()'.

 - Constant: dirWriteDenied
     You need to have write permission for the directory you want to
     add a new file to.

 - Constant: fileError
     Unspecified error when opening/creating a file; this usually means
     that this module doesn't know how to interpret the error code
     delivered by the OS.

 - Constant: nameTooLong
     Either the total length of the file name or of an individual file
     name component is too large; the operating system can impose such
     limits (see PATH_MAX and NAME_MAX in /usr/include/limits.h), or
     the file system itself restricts the format of names on it.

 - Constant: notDirectory
     A file that is referenced as a directory component of the file
     name exists, but is not a directory.

 - Constant: linkLoop
     Too many symbolic links were resolved while trying to look up the
     file name; the operating system has an arbitrary limit on the
     number of symbolic links that may be resolved in looking up a
     single file name, as a primitive way to detect loops.

   The following are possible elements for the FLAGS parameter of
`New', `Old', or `Tmp'.

   *Please note*: at least one of the following flags has to be set;
otherwise you will get an "access denied" error:

 - Constant: read
     If the file cannot be opened for reading access, then it isn't
     opened at all; in this case the error code is set to
     `noReadAccess'.

 - Constant: write
     If the file cannot be opened for writing access, then it isn't
     opened at all; in this case the error code is set to
     `noWriteAccess'.

 - Constant: tryRead
     Try to open this file for reading access; if the file permissions
     don't permit reading, the file is opened nevertheless, but the
     file descriptor's attribute `readable' is set to `FALSE'.

 - Constant: tryWrite
     Try to open this file for writing access; if the file permissions
     don't permit writing, the file is opened nevertheless, but the
     file descriptor's attribute `writable' is set to `FALSE'.


File: OOCref.info,  Node: StdChannels,  Next: ProgramArgs,  Prev: Files,  Up: Channels

Module StdChannels
------------------

   Module StdChannels defines the standard I/O channels, which are
predefined channels for input (typically the keyboard) and output
(typically the computer screen).

   Standard channels do not have to be opened by a client program
because they are already open and ready for use.  Their attributes and
operations are described by the class `Channel.Channel'.

   The standard channels (`stdin', `stdout', and `stderr') should never
be closed.  You *can* close the standard channels (e.g., to detach a
program from its terminal), but `StdChannels' does not provide a way to
reopen them.  Notice that the modules `In', `Out', `Err', `OakIn', and
`OakOut' are all affected by such operations on standard channels.  If,
for example, you call `stdout.Close', then the procedures in module Out
will no longer function (unless you use `Out.SetWriter' to set another
channel).

   A fourth standard channel, `null', is also provided.

   Mappers may be attached to any of these channels to provide read/
write operations for them.  Mappers from module `TextRider' are most
often used.

   Also, be aware that modules `In', `Out', and `Err' provide simple
interfaces to the standard channels (*note Standard I/O::.)  So that,
in many cases, you may not have to use module `StdChannels' directly.

 - Read-only Variable: stdin
     The "standard input" channel, which is a predefined source of
     input for the program.  The referenced channel is read-only.

   *Example:*

     VAR stringVar: ARRAY 256 OF CHAR;
         rdr:       TextRider.Reader;
     
     rdr := TextRider.ConnectReader(StdChannels.stdin);
     rdr.ReadLine(stringVar);

 - Read-only Variable: stdout
     The "standard output" channel, which is a predefined destination
     for output from the program.  The referenced channel is write-only.

   *Example:*

     VAR wrtr: TextRider.Writer;
     
     wrtr := TextRider.ConnectWriter(StdChannels.stdout);
     wrtr.WriteString("A string to write"); wrtr.WriteLn;

 - Read-only Variable: stderr
     The "standard error" channel, which can be used for error messages
     and diagnostics issued by the program.  The referenced channel is
     write-only.

   *Example:*

     VAR wrtr: TextRider.Writer;
     
     wrtr := TextRider.ConnectWriter(StdChannels.stderr);
     wrtr.WriteString("An error has occured"); wrtr.WriteLn;

 - Read-only Variable: null
     The "null" channel, which can be used as a destination for output
     that is to be discarded.  The referenced channel is write-only.


File: OOCref.info,  Node: ProgramArgs,  Prev: StdChannels,  Up: Channels

Module ProgramArgs
------------------

   This module provides access to the command line arguments passed to
the program's invocation.  They are mapped onto a standard channel
`args', with each argument transformed into a single line of text.
Interpreting the list of arguments is usually done by applying an
instance of `TextRider.Reader' or `TextRider.Scanner' to the argument
channel.

   The number of arguments is determined by calling `args.ArgNumber()'.
If the invocation were, for example, `foo bar 42', where `foo' is the
name of the program itself, then the channel's contents would look like
this:

     foo
     bar
     42

   For the above example, `args.ArgNumber()' would return `2'; that is,
the program name is not counted by `ArgNumber' even though it is
present in `args'.

   Note that command line arguments should not contain any end-of-line
characters, otherwise, a single argument would be mapped onto multiple
lines.

   Also, be careful with settings for `TextRider.Reader' and especially
`TextRider.Scanner': end-of-line characters are treated as whitespace
by many of the read operations, which means, for a program `foo', the
reader or scanner has no way of distinguishing between

     foo 123 bar
     for "123 bar"

   You would normally consider the first invocation as having two
arguments, and the second as having one; which is also how ProgramArgs
would interpret them.  For `foo 123 bar', `args' would contain

     foo
     123
     bar

   whereas, for `foo "123 bar"', `args' would contain

     foo
     123 bar

   But a text reader or scanner, if set to treat end-of-line as
whitespace, would treat both of these invocations as equivalent.

     *Please note*: In cases where separate arguments need to be
     considered as a whole, the reader method `ReadLine' should be used.
     Unlike other read operations, such as`ReadInt' or
     `ReadIdentifier', leading whitespace is not skipped and, after
     completion, the reading position is just behind the end-of-line
     character.

     So `ReadLine' should be used to read, for example, file name
     arguments because operating systems like Unix typically allow
     arbitrary characters in file names, including blanks and control
     codes.

   Module `ProgramArgs' provides local equivalents for the following
constants from module `Channels': `done', `outOfRange', `readAfterEnd',
`channelClosed', `noWriteAccess', and `noModTime'.

 - Class: Channel = POINTER TO ChannelDesc
     This class is derived from the abstract base channel class.  In
     addition to its inherited fields and methods (*note Abstract Class
     Channel::.), the class provides the following method:

    Method: `(VAR CH: Channel)' ArgNumber `(): LONGINT'
          Returns the number of command line arguments (excluding the
          program name itself) passed to the program.

 - Read-only Variable: args
     The predefined "program arguments" channel.  The referenced
     channel is read-only.

   As a further example, suppose a program `foo' required exactly two
(positional) command line arguments.  The first is an integer value and
the second is an identifier.  Also, suppose that all of the following
invocations are to be considered equivalent:

     foo 123 bar
     foo +123 bar
     foo "  +123" " bar"

   Note that, the following module would *not* consider `foo 123 " bar
"' or `foo 123+ bar' to be equivalent to the above invocations.

   *Example:*

     VAR r: TextRider.Reader;
         str: ARRAY 256 OF CHAR;
         int: LONGINT;
     
       r := TextRider.ConnectReader(ProgramArgs.args);
       IF r = NIL THEN
          (* Error processing: failed to connect to `args' *)
       END;
     
       IF ProgramArgs.args.ArgNumber() # 2 THEN
          (* Error processing: wrong number of arguments *)
       END;
     
       (* skip past the line containing the program name `foo' *)
       r.ReadLn;
     
       r.ReadLInt(int);
       IF r.Res() # TextRider.done THEN
          (* Error processing: can't read an integer *)
       ELSIF ~r.Eol() THEN
          (* Error processing: this argument has other stuff after
             the integer just read *)
       END;
     
       r.ReadLn; (* skip to the next line *)
     
       r.ReadIdentifier(str);
       IF r.Res() # TextRider.done THEN
          (* Error processing: can't read an identifier *)
       ELSIF ~r.Eol() THEN
          (* Error processing: extra stuff after the identifier *)
       END;


File: OOCref.info,  Node: Standard Mappers,  Next: Standard I/O,  Prev: Channels,  Up: I/O Subsystem

Standard Mappers
================

   Mappers are high-level riders, which are used to translate between a
sequence of data items and an uninterpreted sequence of bytes (*note
Riders and Mappers::.).  Thus, the reader and writer types in
BinaryRider and TextRider are considered mappers.

   The "standard mappers", defined in this section, use the basic riders
associated with a particular channel type for reading and writing bytes.
You'll notice that there are very few error code constants defined
within either of these modules; error codes are dependant on the
channel being read, and so you'll have to use the constant values for
readers and writers that are declared within each particular channel
module.

   Because OOC has both `CHAR' and `LONGCHAR' character types, mappers
for textual data have been set up as a class hierarchy, with base
classes in module `Rider' from which all other text mappers derive.

* Menu:

* Text Mappers::                Textual input from and output to channels.
* BinaryRider::                 Binary input from and output to channels.


File: OOCref.info,  Node: Text Mappers,  Next: BinaryRider,  Up: Standard Mappers

Text Mappers
------------

   The text mapper modules (`Rider', `LongRider', `TextRider', and
`UnicodeRider') provide facilities for reading and writing values in
"text format".  Text format is delimited, or otherwise formatted,
sequences of character values that can be interpreted as words, numbers,
symbols, and so forth.  This corresponds to the way human beings read
text, or perhaps how an Oberon-2 source file is parsed by a compiler.
Data in text format are generally refered to simply as "text".

   Text can usually be interpreted in a limited number of ways.  For
example, the number `2' can be read as an `INTEGER' value or as a
`REAL'.  It could be an element of a `SET', or perhaps even be part of
an identifier such as `oo2c'.  The interpretation is based on context
and the format of the characters rather than as a fixed number of bytes.

   Because the corresponding classes from the text mapper modules
provide related facilities, they form a class hierarchy as follows:

                 Rider [ABSTRACT]
                 /    \
               /        \
             /            \
        TextRider        LongRider [ABSTRACT]
                              |
                              |
                              |
                         UnicodeRider

* Menu:

* Rider::                       Abstract classes for text based I/0.
* LongRider::                   Abstract classes with LONGCHAR support.
* TextRider::                   ISO-Latin-1 (CHAR) text based I/0.
* UnicodeRider::                Unicode (LONGCHAR) text based I/0.


File: OOCref.info,  Node: Rider,  Next: LongRider,  Up: Text Mappers

Module Rider
------------

   Module `Rider' encapsulates the base classes for all other text
mapper classes.  These base classes (`Reader', `Writer', and `Scanner')
are abstract classes that define the interface elements required for
concrete classes derived from them.

   See the concrete text mapper classes for more detail and examples of
usage (*Note TextRider:: and *Note UnicodeRider::).

* Menu:

* Class Reader (Rider)::        Abstract class defining text readers.
* Class Writer (Rider)::        Abstract class defining text writers.
* Class Scanner (Rider)::       Abstract class defining text scanners.


File: OOCref.info,  Node: Class Reader (Rider),  Next: Class Writer (Rider),  Up: Rider

Class Reader (Rider)
....................

 - Constant: maxLengthEol
     The maximum number of characters allowed in `Reader.eol'.

 - Abstract Class: Reader = POINTER TO ReaderDesc
     This class provides facilities for reading various kinds of text.
     Note that this type does not inherit properties from any basic
     reader type; rather it uses the basic reader type associated with
     the channel it is attached to.

     Also note that, after any failed read operation, all further
     attempts to read will be ignored until the error is cleared using
     `ClearError'.

     *Note Class Reader (TextRider):: for examples of usage.

    Field: opt-: `SET'
          The current read options setting for the reader.

    Field: base-: `Channel.Channel'
          This field refers to the channel the reader is connected to.

     The following fields determine how the reader interprets
     end-of-line markers.  Note that the end-of-line marker may contain
     the character `0X', which means its length must be stored in a
     separate field.  The `eol' marker cannot be empty, and all
     characters must be an ASCII code in the range `00X..1FX'.

    Field: eol-: `ARRAY maxLengthEol OF CHAR'
          The character sequence that represents an end-of-line marker.
          Note that this is a character array, *not* a string (i.e.,
          it may contain the character `0X').

    Field: eolLen-: `INTEGER'
          The number of characters in `eol'.  The default value for
          this is `-1', which means that end-of-line is auto detected
          (see `SetEol' below).  Otherwise, this value is in the range
          `1 <= eolLen <= maxLengthEol'.

   The following methods can be used to check the status of a reader
or, in some cases, change its state.  Some methods are fully described
in the abstract reader section (*note Abstract Class Reader::.), so
only brief descriptions of those are given here.

Method: `(R: Reader)' Available `() : LONGINT'
     Returns the number of bytes available for the next read operation.

Method: `(R: Reader)' ClearError
     Clears error conditions on the reader R, re-enabling further read
     operations.

Method: `(R: Reader)' Eol `(): BOOLEAN'
     This method returns `TRUE' if the reader is currently positioned
     at an end-of-line marker (see `SetEol' below).  This will also
     return `TRUE' if `R.Res() # done'.  Otherwise, `FALSE' is returned.

Method: `(R: Reader)' ErrorDescr `(VAR DESCR: ARRAY OF CHAR)'
     Retrieves a descriptive error message string stating the reason
     why one of the previous operations failed.

Method: `(R: Reader)' Pos `(): LONGINT'
     Returns the current reading position associated with the reader R
     in channel `R.base'.

Method: `(R: Reader)' Res `(): INTEGER'
     This method returns the status of the last read operation (e.g.,
     `ReadLine', `ReadInt', `SetPos', etc.).  Note that unlike some
     other reader types, `Res()' is a method rather than a field; but
     otherwise, it performs equivalently.

     Error codes are highly dependent on the channel being read, and
     therefore on the basic riders provided by that channel, so you
     must look at the result codes for a particular channel's reader
     type (e.g., Files.Reader error codes).  See the various channel
     types for details of these error codes (i.e., *Note Files::, *Note
     StdChannels::, or *Note ProgramArgs::).

     Use method `ErrorDescr' to get a plain text error description of
     this error code.

Method: `(R: Reader)' SetEol `(MARKER: ARRAY OF CHAR; MARKERLEN: INTEGER)'
     This method sets the end-of-line marker; that is, what
     character(s) is used to mark the end of a line.  If the passed
     string MARKER does not fit into the field `eol', or if it contains
     a character >= ` ', then `R.Res()' is set to `invalidFormat'.

     A marker length `markerLen=-1' enables auto detection of the
     end-of-line convention used by the channel.  For auto detection to
     work, the channel is required to use one of the following `eol'
     markers:

    `LF'
          used by Unix

    `CR'
          used by MacOS

    `CR/LF'
          used by MS-DOS and Windows

     *Please note:* `ReadChar' is unaffected by the current `eol'
     setting.  That is, if the end-of-line marker consists of more than
     one character (like `CR/LF'), each character is read separately.
     All other read operations view an end-of-line marker at an atomic
     entity when the channel is read sequentially.

     If auto detection is enabled, and the `eol' convention of the file
     is `CR/LF', then the first end-of-line marker is not skipped
     completely when reached by the reader (`R.Pos()' is at the `LF').
     This is transparent to all reading procedures except `ReadChar' and
     `Pos'; the `LF' will be skipped automatically on the next read.
     This positioning inconsistency only applies for the very first
     `eol' encountered.

     *Pre-condition*: All of the following apply:
       1. `r.Res() = done', and

       2. `(markerLen = -1) OR (1 <= markerLen < LEN (marker))', and

       3. `markerLen <= maxLengthEol', and

       4. for all `i': `marker[i] < 20X'

Method: `(R: Reader)' SetOpts `(OPTS: SET)'
     This method is used to set the reader options `R.opt'.

Method: `(R: Reader)' SetPos `(NEWPOS: LONGINT)'
     Sets the reading position to NEWPOS.

   The following methods read a value of the given type from the current
position of the reader.  Most read operations skip leading whitespace
before reading a token; there are only three methods that do not skip
whitespace: `ReadChar', `ReadLn', and `ReadLine'.

   When attempting to read, and if the value is not properly formatted
for its type, `r.Res()' returns `invalidFormat'.  The reader remains
positioned at the character which caused the `invalidFormat' error, but
further reading can not take place until the error is cleared.

   If a number, or potential set element, is properly formatted, but
has a value that is out of range of the target type, then a
`valueOutOfRange' error occurs.  In this case, the reader is positioned
*after* the last character that was read.  Again, further reading can
not take place until the error is cleared.

   A `valueOutOfRange' error also occurs for methods reading into an
`ARRAY OF CHAR' (i.e., `ReadLine', `ReadIdentifier', and `ReadString')
if the character array is not large enough to hold the entire input.

   Otherwise, for any operation attempting to read when there are no
characters left to be read, a read-after-end error occurs and
`Reader.Res()' returns `readAfterEnd'.

   In any case, whenever an error occurs, it is safest to assume that
*no* value has been read.  That is, the variable being read into is
left with an undefined value.

   All further calls of these read methods will be ignored if
`R.Res()#done'.  That is, no new characters will be read if an error
has occurred previously.

Method: `(R: Reader)' ReadBool `(VAR BOOL: BOOLEAN)'
     Reads in an identifier (see `ReadIdentifier' below), and if it is
     either of the tokens `TRUE' or `FALSE', it is converted to a
     `BOOLEAN' value.  If this method encounters any other token, an
     `invalidFormat' error occurs and the value of BOOL is undefined.

Method: `(R: Reader)' ReadChar `(VAR CH: CHAR)'
     Reads in a single character value and places it in CH.

Method: `(R: Reader)' ReadHex `(VAR LINT: LONGINT)'
     Reads in characters in the form of an unsigned hexadecimal number
     and converts them to a `LONGINT' value.

     The first character must be a decimal digit (i.e., `0..9') and
     subsequent characters must be valid hexadecimal digits (i.e.,
     `0..9' or `A..F').  If the first non-whitespace character is not a
     digit, then an `invalidFormat' error occurs.

     If the input is properly formatted as an unsigned hex number, but
     the value is out of range for a `LONGINT', then a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of LINT is undefined.

     *Please note:* Because `LONGINT' values are signed, hex numbers in
     the range `80000000H..FFFFFFFFH' are interpreted as negative
     `LONGINT' values.

Method: `(R: Reader)' ReadIdentifier `(VAR S: ARRAY OF CHAR)'
     Reads an Oberon-2 style identifier into S.  An "identifier" is a
     sequence of letters and digits, which must begin with a letter.

     Sequences not beginning with a letter produce an `invalidFormat'
     error.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.

Method: `(R: Reader)' ReadInt `(VAR INT: INTEGER)'
     Reads in characters in the form of a signed whole number and
     converts them to an `INTEGER' value.

     If the first character is not a digit, a "`+'" sign, or a "`-'"
     sign, then an `invalidFormat' error occurs.

     If the input is properly formatted as a signed whole number, but
     the value is out of range for an `INTEGER', then a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of INT is undefined.

Method: `(R: Reader)' ReadLInt `(VAR LINT: LONGINT)'
     This method provides the same facility as `ReadInt', except that it
     deals with `LONGINT' values.

Method: `(R: Reader)' ReadSInt `(VAR SINT: SHORTINT)'
     This method provides the same facility as `ReadInt', except that it
     deals with `SHORTINT' values.

Method: `(R: Reader)' ReadLine `(VAR S: ARRAY OF CHAR)'
     Reads a sequence of characters into S; reading continues until an
     end-of-line character is encountered, the array S is full, or R
     reaches the end of the channel.  The end-of-line character is
     discarded and S is always terminated with `0X'.

     If R is already positioned at an end-of-line character, S returns
     as an empty string.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs; S returns with the sequence of
     characters that have been read so far (terminated by `0X').

     If R has already reached the end of the channel (i.e., there are no
     more characters left to read), a `readAfterEnd' error occurs and S
     returns as an empty string.

Method: `(R: Reader)' ReadLn
     This method reads and discards all characters up to and including
     the next end-of-line character.  If the end of the channel is
     reached before encountering an end-of-line character, a
     `readAfterEnd' error occurs.

Method: `(R: Reader)' ReadString `(VAR S: ARRAY OF CHAR)'
     Reads in a sequence of characters enclosed in single (`'') or
     double (`"') quote marks.  The opening quote must be the same as
     the closing quote and must not occur within the string.

     Characters will be read until the terminating quote mark is
     encountered, an invalid character is read (end-of-line is always
     considered invalid), there are no more characters available in the
     channel, or the string S is full.  S is always terminated with
     `0X'.

     Unquoted strings produce an `invalidFormat' error.  Strings with no
     terminating quote mark also result in an `invalidFormat' error.

     If S is not large enough to hold the entire input, a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.

Method: `(R: Reader)' ReadReal `(VAR REAL: REAL)'
     Reads in characters in the form of a signed fixed or
     floating-point number and converts them to a `REAL' value.

     If the first character is not a digit, a "`+'" sign, or a "`-'"
     sign, then an `invalidFormat' error occurs.

     If the input is properly formatted as a signed fixed or
     floating-point number, but the value is out of range for a `REAL',
     then a `valueOutOfRange' error occurs.

     Upon encountering an error, the value of REAL is undefined.

Method: `(R: Reader)' ReadLReal `(VAR LREAL: LONGREAL)'
     This method provides the same facility as `ReadReal', except that
     it deals with `LONGREAL' values.

Method: `(R: Reader)' ReadSet `(VAR S: SET)'
     Reads in characters in the form of a set constructor and converts
     them to a `SET'.

     If the sequence of characters does not form a valid set
     constructor, then an `invalidFormat' error occurs.

     If the input is properly formatted as a set constructor, but a set
     element has a value out of the range `0..MAX(SET)', then a
     `valueOutOfRange' error occurs.

     Upon encountering an error, the value of S is undefined.


File: OOCref.info,  Node: Class Writer (Rider),  Next: Class Scanner (Rider),  Prev: Class Reader (Rider),  Up: Rider

Class Writer (Rider)
....................

 - Abstract Class: Writer = POINTER TO WriterDesc
     This class provides facilities for writing various types of text.
     Note that this type does not inherit properties from any basic
     writer type; rather it uses the basic writer type associated with
     the channel it is attached to.

     *Note Class Writer (TextRider):: for examples of usage.

    Field: opt-: `SET'
          The current write options setting for the writer.  See *Note
          Summary of TextRider Constants:: for possible option values.

    Field: base-: `Channel.Channel'
          This field refers to the channel the writer is connected to.

   The following methods can be used to check the status of a writer
or, in some cases, change its state.  Some methods are fully described
in the abstract writer section (*note Abstract Class Writer::.), so
only brief descriptions of those are given here.

Method: `(W: Writer)' ClearError
     Clears error conditions on the writer W, re-enabling further write
     operations.

Method: `(W: Writer)' ErrorDescr `(VAR DESCR: ARRAY OF CHAR)'
     Retrieves a descriptive error message string stating the reason
     why one of the previous operations failed.

Method: `(W: Writer)' Pos `() : LONGINT'
     Returns the current writing position associated with the writer
     `w' in channel `W.base'.

Method: `(W: Writer)' Res `() : INTEGER'
     This method returns the status of the last write operation (e.g.,
     `WriteBytes', `WriteInt', `SetPos', etc.)  Note that unlike some
     other writer types, `Res()' is a method rather than a field; but
     otherwise, it performs equivalently.

     Error codes are highly dependent on the channel being written to
     (and therefore on the basic riders provided for that channel), so
     you must look at the result codes for the basic writer that is
     associated with that particular channel (e.g., Files.Writer error
     codes).  See the various channel types for details of these error
     codes (i.e., *Note Files::, *Note StdChannels::, *Note
     ProgramArgs::)

     Use `ErrorDescr' to get a plain text error description of this
     error code.

Method: `(W: Writer)' SetEol `(MARKER: ARRAY OF CHAR; MARKERLEN: INTEGER)'
     This method sets the end-of-line marker; that is, what
     character(s) is used to mark the end of a line.  If the passed
     string MARKER does not fit into the field `eol', then `W.Res()' is
     set to `invalidFormat'.  The empty marker is permitted.  The
     default value for a newly created writer is `CharClass.systemEol'.

     *Pre-condition*: All of the following apply:
       1. `w.Res() = done', and

       2. `0 <= markerLen < LEN (marker)', and

       3. `markerLen <= maxLengthEol'.

Method: `(W: Writer)' SetOpts `(OPTS: SET)'
     This method is used to set the writer options `W.opt'.

Method: `(W: Writer)' SetPos `(NEWPOS: LONGINT)'
     Sets the writing position to NEWPOS.

   The following writer methods are used to write values in text format
to the underlying channel.  In some situations, it is possible for only
part of the value to be actually written.

Method: `(W: Writer)' WriteBool `(BOOL: BOOLEAN)'
     Writes the value of BOOL as text.  That is, either `TRUE' or
     `FALSE'.

Method: `(W: Writer)' WriteChar `(CH: CHAR)'
     Writes a single character value CH.

Method: `(W: Writer)' WriteHex `(LINT: LONGINT; D: LONGINT)'
     Writes the value of LINT as an unsigned hexadecimal number with a
     minimum field width of D.  Leading zeros are written if the value
     of LINT requires less than D places.  If D is less than or equal
     to zero, field width is 8.

Method: `(W: Writer)' WriteInt `(INT: INTEGER; N: LONGINT)'
     Writes the value of INT as a decimal number with a minimum field
     width of N.  Leading spaces are written if the value of INT
     requires less than N places.  A sign is written only for negative
     values.

Method: `(W: Writer)' WriteLInt `(LINT: LONGINT; N: LONGINT)'
     This method provides the same facility as `WriteInt', except that
     it deals with `LONGINT' values.

Method: `(W: Writer)' WriteSInt `(SINT: SHORTINT; N: LONGINT)'
     This method provides the same facility as `WriteInt', except that
     it deals with `SHORTINT' values.

Method: `(W: Writer)' WriteReal `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a floating-point number with a minimum
     field width of N.

     If the value of K is greater than 0, that number of significant
     digits is included.  Otherwise, an implementation-defined number
     of significant digits is included.  The decimal point is not
     included if there are no significant digits in the fractional part.

     The number is scaled with one digit in the whole number part.  A
     sign is included only for negative values.

Method: `(W: Writer)' WriteLReal `(LREAL: LONGREAL; N, K: LONGINT)'
     This method provides the same facility as `WriteReal', except that
     it deals with `LONGREAL' values.

Method: `(W: Writer)' WriteRealEng `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a floating-point number with a minimum
     field width of N.

     If the value of K is greater than 0, that number of significant
     digits is included.  Otherwise, an implementation-defined number
     of significant digits is included.  The decimal point is not
     included if there are no significant digits in the fractional part.

     The number is scaled with one to three digits in the whole number
     part and with an exponent that is a multiple of three.  A sign is
     included only for negative values.

Method: `(W: Writer)' WriteLRealEng `(LREAL: LONGREAL; N, K: LONGINT)'
     This method provides the same facility as `WriteRealEng', except
     that it deals with `LONGREAL' values.

Method: `(W: Writer)' WriteRealFix `(REAL: REAL; N, K: LONGINT)'
     Writes the value of REAL as a fixed-point number with a minimum
     field width of N.

     The value is rounded to the given value of K relative to the
     decimal point.  The decimal point is suppressed if K is less than
     0.

     The number will have at least one digit in the whole number part.
     A sign is included only for negative values.

Method: `(W: Writer)' WriteLRealFix `(LREAL: LONGREAL; N, K: LONGINT)'
     This method provides the same facility as `WriteRealFix', except
     that it deals with `LONGREAL' values.

Method: `(W: Writer)' WriteSet `(S: SET)'
     Writes the value of S as an Oberon-2 set constructor, including
     curly braces, commas, and range indicators ("`..'") where
     appropriate.

Method: `(W: Writer)' WriteString `(S: ARRAY OF CHAR)'
     Writes a string value up to, but not including, the terminating
     `0X' character.  The behaviour of this method is undefined if S is
     an unterminated character array.

     *Please note:* `ReadString' and `WriteString' *are not* symmetric.
     That is, `WriteString' does not enclose the written string in
     quote marks; only the actual character values contained in S are
     written.

Method: `(W: Writer)' WriteLn
     Writes an end-of-line marker (i.e., a "newline").  The default
     value for a newly created writer is `CharClass.systemEol' (see
     `SetEol' above).


File: OOCref.info,  Node: Class Scanner (Rider),  Prev: Class Writer (Rider),  Up: Rider

Class Scanner (Rider)
.....................

   A "text scanner" is a special type of reader, which is used to parse
text for different kinds of tokens.  Integers, reals, strings,
identifiers, set constructors, the boolean tokens `TRUE' and `FALSE',
and other special symbols are all tokens recognized by this kind of
scanner.

   These tokens are scanned sequentially, converted to an appropriate
type, and then returned in one of the scanner's fields.  The scanner's
`type' field is then used to determine the type of token which has been
scanned.

   Along with some typical reader methods, such as `SetPos', the primary
method of a scanner is `Scan', which simply scans the next token based
on the scanner's current options setting.

   *Note Class Scanner (TextRider):: for examples of usage.

 - Data type: String
     A string type of pre-defined length for use within a scanner.
     Note that because this type is of finite length, a scanner is
     limited in the length of string it can scan.

     *Please note:* `LEN()' can be used on a variable of type `String'
     to determine the maximum size that can be held by a scanner string.

 - Abstract Class: Scanner = POINTER TO ScannerDesc
     This class provides facilities for scanning sequences of
     characters from a channel and parsing those characters into
     various tokens.  The tokens a scanner can recognize are defined by
     the constants provided for its `type' field (*Note Summary of
     TextRider Constants::).

     Note that a scanner will not continue to read (via calls to
     `Scan') if it has scanned an invalid token or an error occurs;
     `ClearError' must be called explicitly before scanning can
     continue.  The difference is that `invalid' means that the token
     could not be interpreted; a sequence of characters was read, but
     could not be interpreted as a valid token.  An `error' occurs when
     there is a problem with the underlying `Reader'; so, `error' is
     used to determine when you have reached end-of-text.

    Field: base-: `Channel.Channel'
          This field refers to the channel the scanner is connected to.

    Field: lines-: `LONGINT'
          Total number of lines (i.e., end-of-line characters) that
          have been scanned.  This number is updated by `Scan'.

    Field: opt-: `SET'
          The current read options setting for the scanner.  See *Note
          Summary of TextRider Constants:: for possible option values.

    Field: pos-: `LONGINT'
          Starting position of the most recently scanned token.  Note
          that this is *not* the same as the value returned by the
          `Pos()' method.

          This value may be useful when an `invalid' token is scanned,
          as it will point to the start of the `invalid' token (whereas
          `Pos()' would be positioned *after* the invalid token).  You
          could, for example, reset the scanner options and re-position
          the scanner back at the invalid token to attempt a re-scan.

    Field: type-: `INTEGER'
          The type of the token that has been most recently scanned.
          The constants `bool', `char', `error', `int', `invalid',
          `line', `ident', `real', `set', `string', `tab', and
          `undefined' are possible values for `type'.  See also the
          related output fields listed below.

     The following are the output fields within a scanner.  Before the
     first call to the `Scan' method, the values of these fields are
     undefined.  After each successive call to `Scan', `type' is set
     and the matching output field contains the value of the scanned
     token.  The value of output fields not corresponding to `type' are
     undefined.

    Field: bool-: `BOOLEAN'
          This field will contain a valid value only if the
          `interpretBools' option is set and one of the tokens `TRUE'
          or `FALSE' is scanned.

    Field: char-: `CHAR'
          Contains a value if `type' is `char', `line', or `tab'.

    Field: int-: `LONGINT'
          Contains a value if `type' is `int'.

          *Please note:* Valid integers are in either signed decimal or
          unsigned hexadecimal formats (hexadecimal tokens *must* be
          terminated with an "`H'" character).

    Field: real-: `LONGREAL'
          Contains a value if `type' is `real'.

    Field: set-: SET;
          Contains a value if `type' is `set'.

    Field: string-: String;
          Contains a value if `type' is `string' or `ident'.

   The following scanner methods are equivalent to the corresponding
reader methods described in *Note Class Reader (TextRider)::, so only
brief descriptions are given here.

Method: `(S: Scanner)' Available `() : LONGINT'
     Returns the number of bytes available for the next scanning
     operation.

Method: `(S: Scanner)' ClearError
     Clears error conditions on the scanner S, re-enabling further
     operations on S.

Method: `(S: Scanner)' ErrorDescr `(VAR DESCR: ARRAY OF CHAR)'
     Retrieves a descriptive error message string stating the reason
     why one of the previous operations failed.

Method: `(S: Scanner)' Pos `(): LONGINT'
     Returns the current reading position associated with the scanner S
     in channel `S.base'.  Note that the value returned by this method
     is different from the position indicated by the scanner's `pos'
     field.

Method: `(S: Scanner)' Res `(): INTEGER'
     This method returns the status of the last read operation (e.g.,
     `Scan', `SetPos', etc.).  Note that `Res()' is a method rather
     than a field; but otherwise, it performs equivalently.

     Use method `ErrorDescr' to get a plain text error description of
     this error code.

Method: `(S: Scanner)' SetEol `(MARKER: ARRAY OF CHAR; MARKERLEN: INTEGER)'
     This method sets the end-of-line marker; it provides the same
     facility as `Reader.SetEol'.  A marker length `markerLen=-1'
     enables auto detection of the end-of-line convention used by the
     channel.

Method: `(S: Scanner)' SetOpts `(OPTS: SET)'
     This method is used to set the scanner options `S.opt'.  See *Note
     Summary of TextRider Constants:: for possible option values.

Method: `(S: Scanner)' SetPos `(NEWPOS: LONGINT)'
     Sets the current scanning position to NEWPOS.

Method: `(S: Scanner)' Scan
     This method skips whitespace, and then scans for the next token as
     specified by the scanning options.  Based on the type of token
     scanned, `S.type' is set and the matching output field is assigned
     a value.

     If the end of the valid text is reached, `S.type' is set to
     `error'.  (Note that `error' is set when the last available valid
     token is read, not necessarily by a `readAfterEnd' condition.)

     Valid tokens are described as follows:

    `bool'
          If `interpretBools' is set as a scanner option, the text
          tokens `TRUE' or `FALSE' are read as `bool'.  (Otherwise,
          these tokens are read as type `ident'.)

    `char'
          Normally, any printable characters other than a letter or
          number and any non-printable control character.  However,
          scanner options will affect what a scanner interprets to be a
          `char':

             * If `interpretSets' is not set, elements of a set
               constructor, "`{'", "`}'", "`,'", are read as `char'
               (and the associated integer constants are read as
               separate tokens).

             * If `interpretStrings' is not set, quote characters are
               read as `char' (and string contents are then read as
               separate tokens).

             * If `useSignedNumbers' is not set, "`+'" and "`-'" are
               read as `char'.  (Otherwise, they are always considered
               part of a number.)

    `int'
          Any Oberon-2 integer constant.  (Note that hexadecimal
          numbers must be unsigned and be terminated with an "`H'".
          Also, lower-case letters, `a..f', are not valid hex digits.)

    `line'
          If `returnCtrlChars' is set, an end-of-line character is read
          as `S.type = line'.  Otherwise, it is counted as whitespace.

    `ident'
          Any Oberon-2 identifier.  (Note that "`_'" is not considered
          as part of an identifier, nor is a selector "`.'".)

    `real'
          Any Oberon-2 real number constant.

    `set'
          Any Oberon-2 set constructor.

    `string'
          Any Oberon-2 string constant.

    `tab'
          If `returnCtrlChars' is set, a tab character is read as
          `S.type = tab'.  Otherwise, it is counted as whitespace.

