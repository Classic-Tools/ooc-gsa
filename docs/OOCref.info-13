This is Info file OOCref.info, produced by Makeinfo version 1.68 from
the input file OOCref.texinfo.

   This file documents the Optimizing Oberon-2 Compiler (OOC) and its
library.

   This is Edition 0.09 DRAFT, last updated 9 July 1999, of `The OOC
Library Reference Manual', for Version 1.4.5 or later of oo2c.

   Copyright (C) 1997-1999 Eric Nikitin Part II Copyright (C) 1998,
1999 Michael van Acken

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU General Public License" must be approved for accuracy by
the Foundation.


File: OOCref.info,  Node: Declaration Flags,  Next: INTERFACE Modules,  Prev: Type Flags,  Up: System Flags

Declaration Flags
.................

   The following table lists non-standard properties that apply to
declarations in external modules:

Variable Declarations

    `NO_DESCRIPTOR'
          Applies to variables of record type.  A record with this
          property cannot appear in type tests and type guards, and it
          cannot be passed to formal parameters that need a type tag.

    `STATIC_POINTER'
          Applies to record pointers, and means that the pointer's
          dynamic type is always equal to its static type.

    `NO_LENGTH_INFO'
          Applies to variables of open array type, and means that the
          predefined function `LEN' cannot be called on this variable.
          Also, the array value cannot be passed to a formal open array
          parameter that expects to get the length of any open
          dimensions.

Parameter Declarations

    `NO_TYPE_TAG'
          Applies to formal variable parameters of record type, and
          means that it is not accompanied by a type tag.  Such a
          parameter cannot appear in a type test or type guard, and it
          cannot be passed to a formal parameter that expects to get a
          type tag.  This flag is implicitly set if the record type is
          marked with `NO_DESCRIPTOR'.

    `NO_LENGTH_TAG'
          Applies to open array parameters, and means that it cannot be
          passed as first argument to `LEN' and cannot be passed to a
          formal open array parameter that expects to get the length of
          any open dimensions.

          If such a parameter is used in a normal Oberon-2 procedure,
          the compiler cannot create a local copy of the array
          argument.  This means that it cannot guarantee the normal
          semantics of value parameters.  (Recall that value parameters
          normally follow these rules: local modifications to the
          parameter stay local, and modifications to the variable that
          was passed to the parameter are not reflected in the
          parameter's local value.)

          In this case, instead of the standard behaviour, the compiler
          treats the parameter like a read-only variable and prevents
          *local changes* to the parameter's value.  However, any
          changes to the original *array variable*, which was passed to
          the parameter in the first place, are reflected by the
          parameter's value.  This resembles the semantics of the
          keyword `const' when applied to C pointer types.

          If the array type is marked with `NO_LENGTH_INFO', this flag
          is implicitly set.

    `NIL_COMPAT'
          Can be applied to any formal parameter passed by reference,
          and means that the value `NIL' can be passed to it.

Linkage Names
     Linkage names can be specified by a string literal, which is
     included in the list of system flags of a variable or procedure
     declaration.  This sets the declaration's C level name.  This
     means that the specified string is used in the emitted C code
     instead of the name generated by `oo2c' (usually module name plus
     two underscores plus declaration name).

Oberon-2 Procedures
     Normally, a procedure declaration in an external module is taken
     to be a declaration of an externally linked procedure definition.
     That is, such procedure declarations usually have no body.  By
     writing `CODE_FILE' into the module header, it is possible to
     define standard Oberon-2 procedures, which have a non-empty body
     part in the module.  Such procedures have to be marked with
     `HAS_BODY'.

Special Code Procedures
     A procedure's list of system flags may contain the directive
     `PROC_ID=n', where `n' is a positive integer constant.  This
     signals the compiler to insert code pattern `n' for every call to
     this procedure.  This is used to implement direct calls of math
     functions built into the processor, or procedures that cannot be
     implemented in the usual way (like the `oo2c' implementation of
     `Exceptions.PUSHCONTEXT').  This flag is of use only when the
     backend is extended to emit code for the new pseudo procedure.


File: OOCref.info,  Node: INTERFACE Modules,  Next: FOREIGN Modules,  Prev: Declaration Flags,  Up: Interfacing to C Code

INTERFACE Modules
-----------------

   An "interface module" describes the Oberon-2 interface to a piece of
existing software.  In the case of `oo2c', this can be a file with C
code, an object file, or a library.  The existing code is not required
to follow the Oberon-2 typing and heap conventions.  Therefore, one
must assume that the semantics of types, variables, and procedures in
such a module are different from their Oberon-2 counterparts.

   Names declared in an interface module, with the exception of the
module name itself, can contain underscores `_' in place of a
character.  The default linkage names of variables and procedures are
the same as their Oberon-2 names, but without a module prefix.  All
other names appearing in the module's C header file get a prefix built
from the module name followed by two underscores.

   None of the record types defined in the module have a type
descriptor, and they cannot be extended.  Likewise, array types have no
type descriptor and open arrays carry no length information.  Pointer
types have no type tag or length information, meaning that type tests,
type guards, and `LEN' cannot be applied to them.  Parameters are
passed without any implicit arguments containing a type tag or length
information.

   The special parameter `...' is permitted as last argument in the
formal parameter list of the declaration of a procedure or a procedure
type.  Note that, in this case, the parameter list has to include at
least one normal parameter.

   The following examples are taken from the Oberon-2 module `X11.Mod',
which defines the interface to the X11 library.  The module header looks
like this:

     MODULE X11 [INTERFACE "C";
                 LINK LIB "X11" ADD_OPTION LibX11Prefix, LibX11Suffix END];

   The first example highlights the basic translation process from a C
header file to an Oberon-2 module, but be aware that the translation
patterns shown are far from exhaustive.  The Oberon-2 counterparts to
the base C types in the header are taken from the standard module
`C.Mod', which also provides two often used character array types.

     From C.Mod:
     char* => TYPE charPtr1d* = POINTER TO ARRAY OF char;
     char** => TYPE charPtr2d* = POINTER TO ARRAY OF charPtr1d;
     
     typedef unsigned long XID;
     => TYPE XID* = C.longint;
     
     #define None 0L
     => CONST None* = 0;
     
     #define NoEventMask  0L
     #define KeyPressMask (1L<<0)
     => CONST NoEventMask* = {};
     => CONST KeyPressMask* = {0};
     
     #define Bool int
     => TYPE Bool* = C.int;
     
     typedef struct {
             int depth;       /* this depth (Z) of the depth */
             int nvisuals;    /* number of Visual types at this depth */
             Visual *visuals; /* list of visuals possible at this depth */
     } Depth;
     => TYPE
       DepthPtr* = POINTER TO Depth;
       Depth* = RECORD
         depth*: C.int;       (* this depth (Z) of the depth *)
         nvisuals*: C.int;    (* number of Visual types at this depth *)
         visuals*: VisualPtr; (* list of visuals possible at this depth *)
       END;
     
     extern XFontStruct *XLoadQueryFont(
         Display* display, _Xconst char* name);
     => PROCEDURE XLoadQueryFont* (
         display: DisplayPtr; name: ARRAY OF C.char): XFontStructPtr;
     
     extern char *XFetchBytes(
         Display* display, int* nbytes_return);
     => PROCEDURE XFetchBytes* (
         display: DisplayPtr; VAR nbytes_return: C.int): C.charPtr1d;
     
     extern Status XGetAtomNames(
         Display* dpy, Atom* atoms, int count, char** names_return);
     => PROCEDURE XGetAtomNames* (
         dpy: DisplayPtr; VAR atoms: ARRAY OF Atom;
         count: C.int; VAR names_return: C.charPtr2d): Status;

   Most of this kind of interface conversion is fairly straightforward.
The most challenging aspect is the handling of pointer types in
parameter lists.  A C pointer argument can be translated into a number
of things: an Oberon-2 pointer type, a variable parameter of the
pointer's base type, an open array parameter, or an array pointer.  The
decision is made depending on the use of the argument in question.  We
can only give rough guidelines here.

   Take, for example, the C function definition

     void f(int *a) {...};

The formal parameter `a' could be either an IN/OUT or an OUT argument,
which translates to

     PROCEDURE f* (VAR a: C.int) ...                      (1)

Or, it could be an array parameter, or an array pointer.  In that case,
it translates to one of the following alternatives:

     PROCEDURE f* (VAR a: ARRAY OF C.int) ...             (2)
     PROCEDURE f* (a: POINTER TO ARRAY OF C.int) ...      (3)
     PROCEDURE f* (a: ARRAY OF C.int) ...                 (4)

The choice depends on how the function `f' accesses the argument `a',
and on whether values passed to this argument are mostly taken from
variables or from the heap.  If `*a' is used as simple integer
variable, it translates to (1).  But if `a' refers to an integer array,
variant (2) is used, and if it is an integer array stored exclusively
on the heap, number (3) might be used.  If the array argument passed to
`f' is not modified by the function, it can be passed as a value array
like in (4); in this case, the C declaration typically adds the prefix
`const' to the parameter.

   Now, consider a pointer argument of a structured based type `T':

     void f(T *a) {...};

which offers one additional translation variant:

     PROCEDURE f* (a: POINTER TO T) ...

Again, whether a pointer value or the variable parameter is used
depends on the primary source of the argument.  If it is taken
exclusively from heap objects, the pointer value is more convenient.
Otherwise, it has to be defined as variable parameter of type `T'.

   Note that the Oberon-2 declarations shown above are not completely
accurate in that it is not possible to use a `POINTER' type constructor
in a formal parameter list.  Instead, such types have to be declared
beforehand and their name used in the parameter list.


File: OOCref.info,  Node: FOREIGN Modules,  Next: Large Arrays of Constants,  Prev: INTERFACE Modules,  Up: Interfacing to C Code

FOREIGN Modules
---------------

   A "foreign module" describes the interface of a standard Oberon-2
module implemented in a non-standard way, say, in assembler or C.  By
default, all declarations are assumed to comply to standard Oberon-2
semantics.  All types defined in such a module behave exactly like
standard Oberon-2 types, and all the normal operations are applicable
to objects declared in a foreign module.  The user cannot distinguish a
foreign module from a normal Oberon-2 module that has been implemented
in the conventional way.

   Care must be taken when integrating the implementation of a foreign
module with the compiler's run-time system.  This is typically done by
writing an empty Oberon-2 module with the desired interface, compiling
it to C code, and then editing the resulting files.

   As a recommended guide, the following steps should be used when
writing foreign modules:

  1. Write an empty module `Foo.Mod' with all exported declarations.

  2. Compile it.

  3. Copy the generated file `Foo.c' to a suitable place, and check
     that the copied file is the one actually used by the compiler, for
     example, by invoking `oowhereis Foo.c'.

  4. In `Foo.c', replace the line `#include "Foo.d"' with the contents
     of the file `Foo.d'.

  5. Modify the module header of `Foo.Mod' to include the proper
     `FOREIGN' directive, and remove all procedure bodies (including the
     procedures' `END' parts).  For a module `Foo', the header should
     look like this:

          MODULE Foo [FOREIGN "C"; LINK FILE "Foo.c" END];

     The command `oocn --filter --mod2foreign Foo.Mod' performs the
     required changes automatically and writes them into the file
     `Foo.txt' (*note oocn options::.).

  6. Fill in all the empty functions in `Foo.c'.  Note that all type
     declarations in function headers should use the `#defines' from
     `__StdTypes.h' (i.e., `CHAR', `BOOLEAN', `SHORTINT', etc.).

   For examples of foreign modules, refer to the implementation of the
library modules `Signal', `PosixFileDesc', or `Files'.


File: OOCref.info,  Node: Large Arrays of Constants,  Next: Limitations of oo2c,  Prev: FOREIGN Modules,  Up: OO2C

Large Arrays of Constants
=========================

   Some algorithms need large arrays of constant values that cannot be
computed by the program itself.  Examples of this are the tables used
to approximate mathematical functions, or the table of hexadecimal
digits of `pi' used by the Blowfish encryption algorithm.  Because such
tables are an integral part of these algorithms, it is not acceptable
to simply read them from external files.

   In Oberon-2, there is basically only one way to create these tables.
That is, declare an array variable and write a huge list of assignments
to fill the table with the desired values.  The problem with this
approach is that it is highly inefficient.  It usually takes a long
time for OOC to compile such a list of assignments, and the generated
code is a highly redundant C file that is translated into a large
object file.

   While it is pointless to undertake any major effort to remedy the
former problem (large tables of constants are too infrequent to make it
worthwhile), it is possible to enhance the code generator to deal with
the latter.  Therefore, `oo2c' has been extended to detect certain
kinds of constant tables and translate them to array definitions with
initialization parts.  However, there are some restrictions:

  1. This mechanism only works for global array variables.

  2. The code to fill the array has to be placed in the module body,
     preferably at its very beginning.

  3. The code cannot be part of an conditional or loop statement; due
     to the peculiarities of OOC's intermediate code representation
     this also implies that it cannot be placed after an `ASSERT' or
     `HALT'.

  4. Any assignment placed after code that might affect the variable is
     ignored, for example, after a procedure call with unknown
     side-effects.  To be safe, all assignments should be placed at the
     very beginning of the module body.

  5. There is a fixed upper limit on the number of constant entries
     (currently this is one million elements).

  6. This mechanism cannot initialize an array of strings; this case is
     translated into a sequence of string assignments as usual.

   An example of this is the module Blowfish(1).  In the module body,
it initializes a two-dimensional array of `LONGINT's with over a
thousand elements.  All of these assignments are removed by the backend
from the code file `Blowfish.c'.  Instead, they appear as part of the
definition of the array variable in `Blowfish.d', reducing the size of
the object file by a significant amount.

   ---------- Footnotes ----------

   (1) To avoid problems with the export legislation of some countries,
the encryption module is distributed as a separate package `bfcrypt'


File: OOCref.info,  Node: Limitations of oo2c,  Next: Emacs Mode,  Prev: Large Arrays of Constants,  Up: OO2C

Limitations of oo2c
===================

   Because the implementation of `oo2c' is a pre-compiler translating
to a high-level language, some run-time checks are only partial
supported, or are not supported at all.  For the complete list of
run-time checks see *Note Options and Pragmas::.

`RealOverflowCheck'
     `oo2c' only detects an overflow when using `SHORT()' to convert a
     `LONGREAL' value to `REAL'.  Other overflows might trigger a
     floating-point exception signal (`SIGFPE') and dump core, or might
     go by unnoticed, depending on the system.

`OverflowCheck'
     `oo2c' does not support any overflow checks for integers.

`StackCheck'
     `oo2c' cannot detect an overflow of the program stack.  If array
     parameters are managed on a separate stack (*note oo2c C
     options::.), enabling this run-time check makes it possible for
     the program to detect an overflow of the auxiliary stack.

   The error reporting of the math modules `LowReal', `LowLReal',
`RealMath', and `LRealMath' is not implemented as described in this
reference manual.  This is a problem of the math modules, not of the
manual.  There is no practical reason why the math modules cannot
adhere to the specifications; but due to lack of time, correct error
reporting has not been implemented yet.


File: OOCref.info,  Node: Emacs Mode,  Next: o2-mode installation,  Prev: Limitations of oo2c,  Up: OO2C

Emacs Mode
==========

   `oo2c' comes with a Oberon-2 major mode for the Free Software
Foundation's GNU Emacs, which helps manage Oberon-2 source code.  It
offers various keyboard shortcuts to insert skeletons for Oberon-2
constructs, locate Oberon-2 files and declarations, compile modules,
and to display error messages.  It can make the task of writing an
Oberon-2 program considerably easier.

   All configuration commands mentioned in the subsequent sections are
also listed in the file `o2-default.el'.  In the distribution archive,
it resides in the `src/tools/emacs' directory.  After installation, it
can be found in the same directory as the file `oberon2.el'.

* Menu:

* o2-mode installation::        Integrating the new package with Emacs.
* o2-mode functions::           Functions provided by Oberon-2 Mode
* o2-mode hints::               Tips and tricks to improve things further.


File: OOCref.info,  Node: o2-mode installation,  Next: o2-mode functions,  Prev: Emacs Mode,  Up: Emacs Mode

Installing the Oberon-2 Package
-------------------------------

   To use the Oberon-2 emacs major-mode, add the following lines to
your Emacs initialization file (`~/.emacs'):

     ;; set load-path to incorporate directory with oberon2.el
     (setq load-path (cons "/usr/local/lib/oo2c" load-path))
     ;; auto load oberon2.el if oberon-2-mode is called
     (autoload 'oberon-2-mode "oberon2" "The Oberon-2 major mode." t)
     ;; set oberon-2-mode as major mode for all files ending in ".Mod"
     (setq auto-mode-alist
             (cons '("\\.Mod$" . oberon-2-mode) auto-mode-alist))

   The file `oberon2.el' is installed during installation of OOC, and so
it may reside in another location than the path given above; modify the
`load-path' setting accordingly.  If you are using Emacs version 19.22
or older, replace `"oberon2"' with `"oberon2_18"' in the line
`(autoload ...)'.  The package `oberon2.el' works only with the
`compile.el' package of Emacs 19.28 (or above, I hope).  Note that
`oberon2_18.el' is an older version of the package, and is no longer
maintained; it does not support all the features of the current version.

   If you have write permissions to system directories, a simple way to
install the Oberon-2 mode for all users on the system is to copy
`oberon2.el' into one of the directories of Emacs's load path (e.g.,
`/usr/lib/emacs/site-lisp').  (To get the list of searched directories
on your system, type `C-h v load-path' in Emacs.)  Then, add the above
commands for `autoload' and `auto-mode-alist' to the file `default.el'.
If no default file exists, you can create one somewhere in Emacs's
load path, say, the same directory you used for `oberon2.el'.  You
could also consider adding the contents of file `o2-default.el' to
`default.el'; among other things, it contains the `autoload' commands
given above.  Assuming that the permissions of both files are correct,
all users on the system should have access to the Oberon-2 mode without
needing to change any personal initialization files.


File: OOCref.info,  Node: o2-mode functions,  Next: o2-mode hints,  Prev: o2-mode installation,  Up: Emacs Mode

Functions of the Oberon-2 Mode
------------------------------

   The keyboard shortcuts listed below are available for every buffer in
Oberon-2 mode.  This list is also available online by pressing `C-h m'
in such a buffer.

   Indentation:

`RET'
     Make a newline, but indent like the previous line.

`TAB'
     Indent `o2-indent' spaces.  With a numeric prefix, indent region.

`DEL'
     Convert tabs to spaces while moving backward.

`C-c TAB'
     Add/remove indentation level(s) to region [deprecated, use `TAB'].

   The variable `o2-ident' determines how many spaces are inserted per
indentation level (the default is 2).

   Inserting Oberon-2 constructs:

`C-c C-c'
     Comment region.

`C-c C-v'
     Uncomment text around point.

`C-c m'
     `MODULE' outline.

`C-c p'
     `PROCEDURE' outline.

`C-c t'
     Type-bound `PROCEDURE' outline.

`C-c C-t'
     Redefinition of type-bound `PROCEDURE'.

`C-c i'
     `IF' ... `THEN' statement.

`C-c C-e'
     Insert `ELSIF'.

`C-c c'
     `CASE' statement.

`C-c C-w'
     `WITH' statement.

`C-c e'
     Insert `ELSE'.

`C-c b'
     Insert a `|'.

`C-c f'
     `FOR' statement.

`C-c w'
     `WHILE' statement.

`C-c r'
     `REPEAT' ... `UNTIL' statement.

`C-c l'
     `LOOP' statement.

`C-c C-r'
     `RECORD' constructor.

`C-c h'
     Comment with various information about the module.

   Move by procedure headings:

`C-c C-n'
     Move to next procedure.

`C-c C-p'
     Move to previous procedure.

`C-c C-u'
     Move to procedure in which the present one is nested.

`M-C-h'
     Put mark at end of procedure, and point at the beginning.

   Functions to hide procedure bodies and declarations:

`C-c C-h'
     Hide whole procedure.

`C-c C-s'
     Show whole procedure again.

`C-c C-l'
     Hide bodies of all local procedures.

`M-x o2-hide-proc'
     Hide local declarations and the procedure body.

`M-x o2-show-proc'
     Show local declarations and body again.

`M-x o2-hide-all'
     Hide all of buffer except procedure headings.

`M-x o2-show-all'
     Make all text in the buffer visible again.

   Managing source code:

`C-c C-f'
     Find file for a given module name.

`C-c 4 f'
     Like `C-c C-f', but display in another window.

`C-c 5 f'
     Like `C-c C-f', but display in another frame.

`C-c C-d'
     Generate and display the definition of a module.

`C-c 4 d'
     Like `C-c C-d', but display in another window.

`C-c 5 d'
     Like `C-c C-d', but display in another frame.

`C-c .'
     Display (same window) the definition of an identifier.

`C-c 4 .'
     Display (other window) the definition of an identifier.

`C-c 5 .'
     Display (other frame) the definition of an identifier.

`C-c /'
     Display, and blink to, declaration of identifier under cursor.

`C-c ,'
     Display (same window) a procedure bound to a given type.

`C-c 4 ,'
     Display (other window) a procedure bound to a given type.

`C-c 5 ,'
     Display (other frame) a procedure bound to a given type.

`C-c u'
     Step through all uses of a declaration with `C-c ''.  All the
above functions accept a module's alias name (as declared in the
current buffers `IMPORT' list) instead of the real module name.  For
further information on `C-c .' or `C-c ,' use `C-h k'.

   Any of the functions that display files in another window or frame
do not change the selected window if the `C-u' prefix is set.  For
example, `C-u C-c 4 .' displays the source of the definition of the
given identifier in another window, but the current window stays
selected and point stays at the current position.

   `S-mouse-3' (i.e., shift with right mouse button), similar to `C-c
/', invokes `C-u C-c 4 .' with the qualified identifier under the mouse
cursor as argument and blink to the found position.

   Compiling:

`M-c'
     Compile current buffer.

`C-u M-c'
     Prompt for compile command and compile current buffer.

`M-C-c'
     Run a make on a module.

`C-c ''
     Display the next error.

`C-c g'
     Prompt for module and error position, goto position.

   Also, please note the following:

   * Searches are case sensitive.

   * Both the `DEL' key and the `backspace' key automatically convert
     tabs to spaces as they step back.

   * In o2-mode, the `TAB' key does not insert any new tab characters,
     but instead, inserts `o2-indent' spaces.

   * `M-;' indents or create a comment on the current line at column 41
     (default).

   * Since GNU Emacs 19.29, the Oberon-2 menu can also be invoked with
     `C-mouse-3' (i.e., control with right mouse button).


File: OOCref.info,  Node: o2-mode hints,  Prev: o2-mode functions,  Up: Emacs Mode

Additional Tips&Tricks
----------------------

   Add `(setq o2-cwd (expand-file-name "dir"))' to `~/.emacs' if you
want Emacs to execute `oo2c', `oob', and so forth in the directory
`dir', regardless of the working directory the editor was started from.

   Typically, the most often used function is the one that places the
cursor at the next error position after a compile.  This is bound to
the 2-key sequence `C-c '' (or `C-c `').  To bind this function to a
single key, say `F8', add one of the following lines to `~/.emacs':

        (global-set-key [f8] 'o2-next-error)

which works under `X' and recent (>=19) versions of Emacs, or

        (global-set-key "[19~" 'o2-next-error)

for text terminals and older versions of Emacs (replace the cryptic
string `[19~' by the one that Emacs produces when pressing `C-q F8').

   If you are working with an X color display, you might try to add the
following piece of code to your `~/.emacs' file (for version 19+).  It
enables the `Font Lock' minor mode for Oberon-2 buffers, colorizing
procedure headers, keywords, comments, pragmas, and strings:

     (add-hook 'oberon-2-mode-hook
     	  (lambda ()
     	    ;(o2-font-lock-hilit-colors)
     	    (turn-on-font-lock)))
     (setq font-lock-maximum-decoration t)

In case you prefer the color scheme of the `hilit19' package, you
should uncomment the function inside the lambda clause above.  Note that
this will change the colors for all buffers with `Font Lock' enabled,
though.  `Font Lock' supports different levels of fontification, with
rendering of higher levels taking more time to display.  The value `t'
selects maximum (and slowest) decoration.

   As another option it is possible to enable a pull-down index menu for
comfortable navigation in a source module.  The index lists all record,
procedure, and type-bound procedure declarations of the module.
Selecting a menu item will move the cursor to the place of the
declaration.  This command enables this feature, adding a "Index"
pull-down menu to the left of the "Oberon-2" menu:

     (add-hook 'oberon-2-mode-hook
               (lambda ()
                 (imenu-add-to-menubar "Index")))

   Other possible additions to `~/.emacs' are the commands listed below.
They put compilation shells into special frames instead of splitting
the current frame.  The special frames are of height 10 and placed in
the upper right corner of the display; they use a smaller font, menu
and scroll bars are disabled, and the frame raises itself to the
foreground when the mouse cursor enters it and lowers itself when left
by the mouse cursor.  *Please note*: This only works with Emacs
versions 19.31 and higher.  These settings are included in file
`o2-default.el'

     (if window-system
         (let ((o2-frame-params
                '((height . 10)
                  (unsplittable . t) (menu-bar-lines . 0)
                  (left . (- 0)) (top . 0) (user-position . t)
                  (font . "5x7") (width . 60) (auto-raise . t)
                  (vertical-scroll-bars . nil) (auto-lower . t)
                  (name . "o2-compilation"))))
           (setq special-display-regexps
                 `(("^\\*o2-compile.*\\*$" . ,o2-frame-params)
                   ("^\\*o2-make.*\\*$" . ,o2-frame-params)))))


File: OOCref.info,  Node: Syntax of Text Tokens,  Next: SYSTEM,  Prev: OO2C,  Up: Top

Syntax of Text Tokens
*********************

   This section describes the accepted syntax for text tokens used by
the various modules within the OOC library.  These definitions apply to
read operations on text, and to modules like *Note IntStr::, *Note
RealStr::, and *Note LRealStr::, which convert between string values
and numeric representation.

   These may also apply to write operations for text, but there are
some cases (like `writer.WriteString' in *Note Class Writer
(TextRider)::) that do not strictly adhere to these definitions.  Also
note that internal representation of strings is different from text
representation of strings.

   An "identifier", sometimes referred to as a "name", has the form

       letter {letter | decimal_digit}

   (Note that an underscore `_' is not considered to be part of an
identifier, nor is a selector `.')

   A "string" has the form

       """ {non_control_char} """ |
       "'" {non_control_char} "'".

   where a "non-control char" is any character with an ordinal value
greater than or equal to a space character (i.e., `non_control_char >=
20X').

   A "signed whole number" (used to represent an integer value) has the
form

       ["+" | "-"] decimal_digit {decimal_digit}.

   An "unsigned hexadecimal number" (used to represent an integer value)
has the form

       ["+" | "-"] decimal_digit {hex_digit}.

   where a "hex digit" is one of `0..9' or `A..F'. (Note that
lower-case letters, `a..f', are not valid hex digits.)

   A "signed fixed-point real number" has the form

       ["+" | "-"] decimal_digit {decimal_digit} ["." {decimal_digit}].

   A "signed floating-point real number" has the form

       ["+" | "-"] decimal_digit {decimal_digit} ["." {decimal_digit}]
                   ("E" | "e") ["+" | "-"] decimal_digit {decimal_digit}.

   A "set constructor" has the form

       "{" [set_element {"," set_element}] "}".

   where a "set element" has the form

       set_value [".." set_value].

   with "set value" being an integer number in the range `0..MAX(SET)'.


File: OOCref.info,  Node: SYSTEM,  Next: OOC Error Messages,  Prev: Syntax of Text Tokens,  Up: Top

SYSTEM module
*************

* Menu:

