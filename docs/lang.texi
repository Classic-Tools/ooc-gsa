@node Language, Pragmas, Localization, Top
@unnumbered Part II:  The OOC Compiler
@chapter Language

The Oberon-2 language as implemented by OOC is based on the paper

@format
@cite{The Programming Language Oberon-2}
H. Moessenboeck, N. Wirth
Institut fuer Computersysteme, ETH Zurich, March 1995
@url{ftp://ftp.inf.ethz.ch/pub/Oberon/Docu/Oberon2.Report.ps.gz}
@end format

This paper describes the language in just 16 pages.  Additional appendices
cover implementation details of Oberon-2 and its implementation as part of
the Oberon operating system for the Ceres workstation.  These appendices are
system dependent, and are only partially implemented by OOC.

This chapter is intended as a supplement to the language report.  Together
with the report, it describes the programming language accepted by OOC
compilers.  It specifies details left open by the report and those features
of OOC that go beyond the scope of the language report.

@menu
* Specifications::              Specifications beyond the language report.  
* Non-conformant Mode::         Deviations from the Language Report in 
                                  "Non-conformant" Mode.  
* Additional Data Types::       Additional basic data types used by OOC.
* Language Extensions::         Experimental extensions to the language.
* Illegal Operations::          Illegal operations and their effects.  
@end menu


@node Specifications, Non-conformant Mode, Language, Language
@section Specifications
@cindex string length
@cindex identifier length
@cindex size of basic types
@cindex empty string
@cindex zero-length arrays
@cindex hexadecimal constants
@cindex DIV
@cindex MOD
@cindex NEW
@cindex HALT
@cindex ASSERT
@cindex SYSTEM.MOVE

@subheading Length limits of Identifiers and Strings
OOC does not impose a limit on the length of identifiers or string literals.
The Oakwood guidelines suggest that a compiler should support at least 23
significant characters for identifiers, but there is no such suggestion for
strings.  The pragma variables @samp{IdentLength} and @samp{StringLength}
control the length of identifiers and string literals accepted by the
compiler (@pxref{Options and Pragmas}).  Note that other compilers may
impose arbitrary limits on identifiers and strings.

@subheading Basic Types
The basic types of OOC are defined as follows:

@smallexample
=============================================================
Name       Size in Bytes             MIN(T)            MAX(T)
-------------------------------------------------------------
BOOLEAN         1                      n/a                n/a
CHAR            1                       0X               0FFX
SHORTINT        1                     -128                127
INTEGER         2                   -32768              32767
LONGINT         4              -2147483648         2147483647
HUGEINT         8                    -2^63             2^63-1
REAL            4          -3.40282347E+38     3.40282347E+38
LONGREAL        8         -1.79769313D+308    1.79769313D+308
SET             4                        0                 31
-------------------------------------------------------------
@end smallexample

The integer type @code{HUGEINT} is required to be implemented only by
compilers for 64-bit target architectures; that is, for targets whose
address size is 8 bytes.  @code{HUGEINT} is optional for all other
implementations of OOC.

The size and extreme values of the real numeric types depend on the floating
point representation used on the target system.  For the vast majority of
modern systems, this will be based on the IEEE standard 754-1985.  In this
case, @code{REAL} is encoded as IEEE single precision number in 4 bytes, and
@code{LONGREAL} as double precision number in 8 bytes.  The numbers given in
the table above assume IEEE representation for real numeric types.  Note
that the extreme values as shown for @code{LONGREAL} are truncated; for the
exact absolute value, refer to the constant @code{LowLReal.large}.

@subheading Empty String
The string constant @samp{""} and the character constant @samp{0X} are
interchangeable.  This implies that a string constant cannot contain
the character @samp{0X}.

@subheading Array Types of Length Zero
Arrays of length zero are permitted, but the compiler will emit a warning if
it detects such an array during compilation (unless warnings are disabled).

So, a declaration of the form @code{TYPE T=ARRAY 0 OF CHAR} is allowed, and
variables of type @code{T} can be defined, but any attempt to access
elements in the array will cause an @samp{index out of range} error either
during compilation (if detectable) or at run-time.  Similarly, open array
instances of length zero can be created (by passing a length of zero to
@code{NEW}), but, of course, no elements can be accessed.

Note that, in any case, specifying a negative length will trigger an error
either during compilation or at program run-time.

@subheading Extension Limit of Record Types
OOC does not impose any limit on the number of levels a record type may be
extended.  The Oakwood guidelines suggest that the number of levels of type
extension should not be less than 8 levels, including the base type.

@subheading Ordering Restrictions for Type-bound Procedures
If an extended record type redefines a type-bound procedure, then the
redefinition must appear @emph{after} the base declaration in the source
text.  The following example violates this rule:

@smallexample
TYPE
  R0 = RECORD END;
  R1 = RECORD (R0) END;

PROCEDURE (VAR r: R1) P; END P;
PROCEDURE (VAR r: R0) P; END P;
@end smallexample

In order to make this example legal, the order of declaration of the two
procedures must be reversed.  Note that this problem can only arise if
the record types, and their corresponding type-bound procedures, are
defined in the same module.  This restriction is inherently present in
many Oberon-2 compilers, although it is not stated in the language
report.

@subheading Large Hexadecimal Constants
Hexadecimal constants can be specified over the full @emph{unsigned} range of
the largest integer type.  A constant value greater than the maximum value of
the largest @emph{signed} integer type is mapped onto a negative value by
interpreting it as an unsigned representation of an integer number.

For example, if the compiler does not support the @code{HUGEINT} type,
hexadecimal constants in the range @samp{08000000H..0FFFFFFFFH} are mapped
into the range @samp{MIN(LONGINT)..-1} by matching the bit pattern of the
constant onto the negative value.  However, if @code{HUGEINT} constants are
supported by the compiler, these values are mapped into the @emph{positive}
range @samp{2^31..2^32-1}.  This means that the interpretation of such
constants is compiler-dependent.  Without special precautions, modules using
this constant representation are not portable to systems that support
additional, larger integer types.

Note that the extended mapping of constant literals applies only to values
given in hexadecimal format; a decimal integer constant will cause an
overflow if it exceeds the maximum integer value.  Special handling of
hexadecimal constants is not part of the language report, but is implemented
in many Oberon-2 compilers, presumably to ease the implementation of
low-level modules that need a convenient way to define bit pattern values of
word size.

@subheading Specification of @code{DIV} and @code{MOD}
The results of integer division and modulus are defined as

@example
x=(x DIV y)*y + x MOD y
@end example

@noindent
where @samp{0 <= x MOD y < y} @emph{or} @samp{y < x MOD y <= 0}.

@emph{Example:}  

@example
=================================
  x    y       x DIV y   x MOD y
---------------------------------
  5    3          1         2   
  5   -3         -2        -1   
 -5    3         -2         1   
 -5   -3          1        -2   
---------------------------------
@end example

Note that with this definition the equation @samp{x DIV y = ENTIER (x/y)}
holds.

@subheading Predefined Procedure @code{NEW}
There are two points of clarification regarding OOC's implementation of
@code{NEW}:

@itemize @bullet
@item
Passing negative length values to the predefined procedure @code{NEW} is
illegal.  An exception is raised during any attempt to create an open array
with a negative length as one of its dimensions.  A length of zero is
permitted, but no read operations on such an array are possible; note that,
writing @samp{NEW(a,0)} triggers a compile-time warning (if warnings are
enabled).

@item
@samp{NEW(v)} or @samp{NEW(v, @dots{})} always returns a non-@code{NIL}
value in @samp{v}.  If the program cannot obtain the required amount of
memory, an exception is raised.
@end itemize

@subheading Predefined Procedures @code{HALT} and @code{ASSERT}
The statements @samp{HALT(n)} and @samp{ASSERT(FALSE, n)} are equivalent to
the C function invocation @samp{exit(n)} unless the raised exception is
caught explicitly.  The value of @samp{n} must be from the range
@samp{[0..255]}.  The statement @samp{ASSERT(FALSE)} is equivalent to
@samp{ASSERT(FALSE, 1)}.

@subheading Predefined Procedure @code{SYSTEM.MOVE}
There are several points to consider when using @code{SYSTEM.MOVE}:

@itemize @bullet
@item
Calling @code{SYSTEM.MOVE} with a block size of zero will do nothing.

@item
The behaviour of @samp{MOVE(src,dest,len)} is undefined when
@itemize @bullet
@item the block size @samp{len} is negative, or
@item the intersection of the ranges @samp{[src..src+len-1]} and
@samp{[dest..dest+len-1]} is not empty, or
@item one of the memory regions @samp{[src..src+len-1]} or
@samp{[dest..dest+len-1]} is not wholly contained in a variable or an
allocated heap object.
@end itemize
@end itemize

Also note that, due to the way OOC represents source code internally,
@code{SYSTEM.MOVE} should not be applied to local scalar variables of a
procedure.  OOC will not recognize such a memory-level copy as a defining
instruction of a variable.  The generated code would be valid, but it is
possible that a warning will be emitted, stating that the variable is not
defined before its use.



@node Non-conformant Mode, Additional Data Types, Specifications, Language
@section Non-conformant Mode
@cindex conformant mode
@cindex non-conformant mode
@cindex WITH
@cindex procedure values
@cindex INC
@cindex DEC
@cindex procedure redefinition

OOC has two, slightly different, modes of operation: conformant mode and
non-conformant mode.  Conformant mode emulates the behaviour of ETH
compilers, whereas non-conformant mode is generally closer to the language
report.  The mode in use is determined by the boolean pragma variable
@samp{ConformantMode} (@pxref{Options and Pragmas}); non-conformant mode is
the default setting.  The differences between both modes are described in
the following sections.

@subheading Implementation of @code{WITH}
In older ETH compilers, the implementation of the @code{WITH} statement is
faulty.  If a guarded variable is a formal parameter, the formal parameter
type is actually modified by the @code{WITH} statement; that is, the
interface of the procedure is changed for any calls to it within the scope
of the regional type guard.

@emph{Example:}  

@smallexample
MODULE TestWith;

TYPE
  R0 = RECORD END;       P0 = POINTER TO R0;  
  R1 = RECORD (R0) END;  P1 = POINTER TO R1;
  
PROCEDURE Proc0 (VAR r: R0);
  VAR r0: R0;
  BEGIN
    WITH r: R1 DO  Proc0 (r0)  END
  END Proc0;

PROCEDURE Proc1 (p: P0);
  VAR p0: P0;
  BEGIN
    WITH p: P1 DO  Proc1 (p0)  END
  END Proc1;

END TestWith.
@end smallexample

In conformant mode, the compiler warns that the formal parameter type is
modified by a @code{WITH} statement, and two errors are issued: the argument
of the first procedure call @samp{Proc0 (r0)} is not compatible to a formal
parameter of type @samp{R1}, and in the second call @samp{Proc1 (p0)}, the
argument is not assignment compatible to type @samp{P1}.  This example
module is legal in non-conformant mode.

@subheading Comparing Procedure Values
The language report specifies that a variable of pointer type cannot be
compared with a procedure constant.  Appendix A states that, for an
expression @samp{p0 = p1} where @samp{p0} and @samp{p1} are procedure
values, both operands have to have the same type.  However, the type rules
imply that the type of any one procedure is distinct from all other types.

@emph{Example:}  

@smallexample
MODULE ProcCmp;

VAR p0, p1: PROCEDURE; bool: BOOLEAN;
  
PROCEDURE P; END P;

BEGIN
  p0 := P;
  bool := (p0 = P)
END ProcCmp.
@end smallexample

The assignment to @samp{p0} is legal, but the comparison between the
procedure variable and the procedure value is not.  Oberon-2 relaxes the
type rules for assignments involving procedure types by requiring only
structural equivalence rather than name equivalence.  It would be
natural to extend this to comparisons of procedure values as well.
Because omitting this extension is most likely an oversight by the
language designers, OOC implements the less restrictive rule.  This
means, that a comparison like in the example is legal in non-conformant
mode, but will be marked as faulty in conformant mode.

@subheading Specification of @code{INC} and @code{DEC}
The report defines @samp{INC(v, n)} to be functionally equivalent to @samp{v
:= v + n}, and gives a similar definition for @samp{DEC(v, n)}.  It does not
specify any type rules for these predefined procedures.  ETH compilers
implement the procedures in such a way that @samp{INC(v, n)} is legal, if

@itemize @bullet
@item @samp{n} is an integer constant included in the type of @samp{v}, or
@item @samp{n} is an expression or variable with the @emph{same} type as
@samp{v}.
@end itemize

Because this implementation is questionable when compared with the language
report, OOC applies a less restrictive rule in non-conformant mode;
@samp{INC(v, n)} and @samp{DEC(v, n)} are valid if the type of @samp{n} is
included in that of @samp{v}, regardless of @samp{n} being a constant value
or not.  In conformant mode, the more restrictive interpretation of the ETH
compilers is applied.

@subheading Redefinition of Type-bound Procedures
The language report specifies that, when redefining a type-bound
procedure, the formal parameters of the original procedure and the
redefinition must @emph{match}.  OOC enfores this rule in conformant
mode.  However, in non-conformant mode, the compiler applies a less
restrictive rule that was first introduced by Oberon/F: If @code{P'} is
a redefinition of the type-bound procedure @code{P}, the formal
parameters of @code{P} and @code{P'} must @emph{match} with the
exception of the function result of @code{P'}, which may be an extension
of the result of @code{P}.

@emph{Example:}

@smallexample
MODULE Redef;

TYPE
  R0 = RECORD END;      P0 = POINTER TO R0;
  R1 = RECORD (R0) END; P1 = POINTER TO R1;

PROCEDURE (p: P0) Copy(): P0; @dots{} END Copy;
PROCEDURE (p: P1) Copy(): P1; @dots{} END Copy;

END Redef.
@end smallexample

In conformant mode, the compiler will complain that the formal parameters of
the second procedure do not match the ones of the first.  Conformant mode
requires the result type of the second procedure to be @samp{P0}, whereas
non-conformant mode allows the extended type @samp{P1} as valid.

By allowing the less restrictive rule for return types, it is possible to
design class hierachies distributed over several modules where an extended
class can be used without direct knowledge of the base class.  An example of
this is found in the module @samp{Files}: If adhering to the report, the
type-bound procedures @samp{NewReader} and @samp{NewWriter} would need to
return types imported from module @samp{Channel}.  Any module using these
procedures would also need to import @samp{Channel} to define variables to
hold the result of these procedures.  With the relaxed redefinition rule,
the procedures can return types from module @samp{Files}, and can therefore
be used separately from the base module @samp{Channel}.



@node Additional Data Types, Language Extensions, Non-conformant Mode, Language
@section Additional Data Types
@cindex set types
@cindex 64-bit data types
@cindex ADDRESS
@cindex LONGCHAR
@cindex long strings
@cindex strings, long
@cindex unicode
@cindex character types
@cindex string constants

OOC provides several data types beyond the standard types of Oberon-2.  They
are introduced to add Unicode support and to ease interfacing to foreign
code and migration to 64-bit target architectures.


@subheading LONGCHAR and Long Strings
In order to support the Unicode character set, OOC adds the type
@code{LONGCHAR} and introduces the concept of long strings.  The
@dfn{character types} are now @code{CHAR} and @code{LONGCHAR}, and
@dfn{string constants} can be either @code{String} or @code{LongString}.


The basic character types are as follows:

@table @code
@item CHAR
the characters of the ISO-Latin-1 (i.e., ISO-8859-1) character set
(0X..0FFX)
@item LONGCHAR
the characters of the Unicode character set (0X..0FFFFX)
@end table


The character type @code{LONGCHAR} includes the values of type @code{CHAR}
according to the following hierarchy:

@example
  LONGCHAR >= CHAR
@end example

Character constants are denoted by the ordinal number of the character in
hexadecimal notation followed by the letter @samp{X}.  The type of a
character constant is the minimal type to which the constant value belongs.
(i.e., If the constant value is in the range @samp{0X..0FFX}, its type is
@code{CHAR}; otherwise, it is @code{LONGCHAR}.)

String constants are sequences of characters enclosed in single (@code{'})
or double (@code{"}) quote marks; strings can also be represented using the
string concatenation operator @samp{+} and a combination of characters or
string constants.  String constants that consist solely of characters in the
range @samp{0X..0FFX} are of type @code{String}, all others are of type
@code{LongString}.  For example, the following is of type @code{LongString}:

@emph{Example:}  

@smallexample
  CONST
     aLongString = 0C0ACX + 0C6A9X + " " + 0C2E4X + 0D328X; 
@end smallexample

The string type @code{LongString} includes the values of type @code{String}
according to the following hierarchy:

@example
    LongString => String
@end example

This means that a string constant composed of @code{CHAR} range values can
be used in place of a constant string composed of @code{LONGCHAR} range
values.  The expected implicit type conversion rules (similar to integer
types) apply to character values and string constants, too; that is, it is
possible to compare a @code{LongString} with a @code{String}, or assign a
@code{String} to an @code{ARRAY OF LONGCHAR} variable.  (@code{CHAR} and
@code{Strings} are promoted to @code{LONGCHAR} and @code{LongString} when
necessary.)


The following predeclared function procedures support these
additional operations:

@smallexample
Name        Argument type        Result type  Function
CAP(x)      CHAR                 CHAR         if x is a letter,
            LONGCHAR             LONGCHAR     corresponding capital
                                              letter; otherwise, 
                                              identity (see note below).

LONG(x)     CHAR                 LONGCHAR     identity 
            String               LongString   identity 

LONGCHR(x)  integer type         LONGCHAR     long character with
                                              ordinal value x

ORD(x)      LONGCHAR             LONGINT      ordinal value of x

SHORT(x)    LONGCHAR             CHAR         projection 
            LongString           String       projection 
@end smallexample

@strong{Please note}:

@code{CAP(x)} maps lower case letters in the ISO-Latin-1 range to the
capital counterparts and produces identity for all other characters (meaning
that most Unicode characters are mapped to identity).  There are two
exceptions: @samp{U+00DF} (LATIN SMALL LETTER SHARP S) whose uppercase
version is the two letter sequence @samp{SS}, and @samp{U+00FF} (LATIN SMALL
LETTER Y WITH DIARESIS) whose capital version is outside the ISO-Latin-1
range (it has the code @samp{U+0178}); these two characers are also mapped
onto themselves.


@code{SHORT(x)}, where @code{x} is of type @code{LONGCHAR}, can result in
overflow, which triggers a compilation or run-time error.  The result of an
operation that causes an overflow, but is not detected as such, is
undefined.


The predeclared procedure @code{COPY(x, v)} also supports
@code{LongStrings}:

@smallexample
 Name            Argument type                 Function
 COPY(x, v)      x: character array, string    v := x
                 v: character array
@end smallexample

Note that, @code{COPY(x, v)} is invalid if @code{x} is of type @code{ARRAY
OF CHAR}, and @code{v} is of type @code{LongString} or @code{ARRAY OF
LONGCHAR}.


@subsubheading Assignment Compatibility
Characters, string constants, and arrays of characters are assignment
compatible as follows:

An expression @code{e} of type @code{Te} is @code{assignment compatible}
with a variable @code{v} of type @code{Tv} if one of the following
conditions hold:

@enumerate a
@item
@code{Tv} and @code{Te} are character types and @code{Tv} includes
@code{Te};
@item
@code{Tv} is an @code{ARRAY n OF LONGCHAR}, @code{Te} is a string constant
with @code{m} characters, and @code{m} < @code{n};
@item
@code{Tv} is an @code{ARRAY n OF CHAR}, @code{Te} is a @code{String} with
@code{m} characters, and @code{m} < @code{n};
@end enumerate


@subsubheading Array Compatibility
String constants and arrays of characters are array compatible as follows:

An actual parameter @code{a} of type @code{Ta} is array compatible with a
formal parameter @code{f} of type @code{Tf} if

@enumerate a
@item
@code{f} is a value parameter of type @code{ARRAY OF CHAR} and @code{a} is a
@code{String}, or
@item
@code{f} is a value parameter of type @code{ARRAY OF LONGCHAR} and @code{a}
is a string constant.
@end enumerate


@subsubheading Expression Compatibility
Character and string types are expression compatible as follows:

@example
Operator        First operand   Second operand  Result type
= # < <= > >=   character type  character type  BOOLEAN
                string type     string type     BOOLEAN
@end example

@strong{Please note}: Implicit type conversion rules apply to both character
values and constant strings.  They do @emph{not} apply to character arrays.


@subsubheading Library support for LONGCHAR

The following modules provide support for @code{LONGCHAR} and
@code{LongString}:

@table @file
@item BinaryRider
Reading and writing of @code{LONGCHAR} and @code{LongString} as binary data.
@item Calendar
Procedures TimeToLStr and LStrToTime.
@item LongStrings
Similar to module @file{Strings}.
@item LongRider [ABSTRACT]
Abstract text mapper classes for @code{LONGCHAR} and @code{LongString}.
@item UnicodeRider
Concrete text mapper classes giving Unicode support.
@end table

Additional mapper classes, which are extended from TextRider and
UnicodeRider, can be added to handle additional 8- and 16-bit encodings.
These classes are used to map from another encoding (e.g., ``KSC5601'', a
standard Korean character encoding) to Unicode or Latin-1 (as appropriate),
and vice versa.  Here ``encoding'' means both the encoding of @code{n} bit
values in byte streams @emph{and} translation of character codes between the
two standards.  (@xref{Standard Mappers}.)


@subheading Additional Set Types
In addition to the standard set type @code{SET}, module @code{SYSTEM}
defines several other set types: @code{SET8}, @code{SET16}, @code{SET32},
and---optionally---@code{SET64}.  The set type @code{SET64} is required to
be implemented only by compilers for 64-bit target architectures.  Note that
the type @code{SET32} is an alias for the standard type @code{SET}.

@smallexample
=============================================================
Name       Size in Bytes             MIN(T)            MAX(T)
-------------------------------------------------------------
SET8            1                        0                  7
SET16           2                        0                 15
SET32           4                        0                 31
SET64           8                        0                 63
-------------------------------------------------------------
@end smallexample

To assign a value to a variable of one of these set types, prefix the set
constructor with the type name.

@emph{Example:}

@smallexample
set8  := SYSTEM.SET8@{0..3@};
set16 := SYSTEM.SET16@{0, 8..x@}; 
@end smallexample 

Operations for the additional set types are defined just like their
counterparts for @code{SET}.  However, both sides of a dyadic operator must
be of the same type.  That is, set operations such as intersection, union,
and so on, are only permitted if both the left and right side are of the
same set type.

The predefined procedures @code{EXCL}, @code{INCL}, and the membership test
@code{IN} are applicable to all set types.  The predefined function
@code{LONG} converts a set value to the identic value of the next larger set
type (if available), whereas @code{SHORT} converts to the next smaller set
(if available).  @code{SHORT} will remove all elements that are not included
in the smaller type.

Variables of type @code{SET8} can be assigned to variables of type @code{BYTE}.
If a formal variable parameter is of type @code{BYTE}, then the corresponding
actual parameter can be of type @code{SET8}.


@subheading Data Types for 64-bit Machines
The Oberon-2 language specification does not give fixed values for the size
of its basic data types.  Any actual language implementation, in the form of
a compiler, has to define the size of its types as fixed values.  Most
modern Oberon-2 compilers use the type sizes listed in the table in
@ref{Specifications}.  However, problems arise when changing to a 64-bit
target system.

Unfortunately, the pseudo module @code{SYSTEM} as defined in the language
report uses an integer type, @code{LONGINT}, to represent memory addresses.
For a 64-bit machine a 64-bit integer type is required to represent
addresses.  Defining @code{LONGINT} to be a 8 byte type on those machines
introduces a number of problems:

@itemize @bullet
@item 
The size of data structures containing @code{LONGINT} grows, possibly
doubling the amount of memory required to store them.
@item
Modules reading or writing binary word data have to be rewritten to further
comply with established protocols.
@item
The interface definitions to external code have to be changed if they used
@code{LONGINT}.  Accordingly, all modules using these interfaces also need
to be rewritten.
@end itemize

Therefore, OOC introduces a new integer type called @code{HUGEINT}, and
leaves existing integer types unchanged.  Values of type @code{HUGEINT} are
stored in 8 bytes, with a minimum value of @samp{-2^63} and a maximum of
@samp{2^63-1}.  This extends the integer type inclusion hierachy at its
upper end.  All integer operations also apply to @code{HUGEINT}.

The integer type @code{HUGEINT} is required to be implemented only by
compilers for 64-bit target architectures; that is, for targets whose
address size is 8 bytes.  @code{HUGEINT} is optional for all other
implementations of OOC.  64-bit systems are also required to implement the
set type @code{SYSTEM.SET64}, which is of the same size as @code{HUGEINT}.  


@subheading Address Type
The pseudo module @code{SYSTEM} declares the type @code{ADDRESS}.  On 32-bit
systems, it is an alias for @code{LONGINT}, and on 64-bit machines, it is an
alias for @code{HUGEINT}.  The following relation holds for all systems:

@smallexample
SIZE(SYSTEM.ADDRESS) = SIZE(POINTER) = SIZE(SYSTEM.PTR).
@end smallexample

The predefined function @code{ADR} returns a value of type @code{ADDRESS}.
Likewise, the type of the address arguments of @code{MOVE}, @code{GET},
@code{PUT}, and @code{BIT} is @code{ADDRESS}.  Note that, for 32-bit
systems, this corresponds to the language report because @code{ADDRESS}
is an alias for @code{LONGINT} on these systems.


@node Language Extensions, Illegal Operations, Additional Data Types, Language
@section Experimental Language Extensions
@cindex language extensions
@cindex OOC_EXTENSIONS flag

Language extensions are implemented by OOC in the framework of system
flags (@pxref{System Flags}).  Instead of extending the syntax of the
language Oberon-2, additional flags are defined to specify non-standard
attributes of data types and declarations.  To enable any OOC specific
extensions for a module, the module must be declared with the
@samp{OOC_EXTENSIONS} flag:

@smallexample
MODULE Foo [OOC_EXTENSIONS];
@end smallexample

To convert a module employing OOC specific extensions to standard
Oberon-2, use the command @kbd{oocn --filter --strip-system-flags}
(@pxref{oocn options}).

@menu
* ABSTRACT::                    Abstract classes and methods.
* NO_COPY::                     Avoiding Local Copies of Value Parameters.
@end menu



@node ABSTRACT, NO_COPY, , Language Extensions
@subsection Abstract Classes
@cindex abstract class
@cindex abstract method
@cindex ABSTRACT flag

@emph{Please note}: This section was contributed by Stewart Greenhill.

Abstract classes are an important technique for separating interfaces from
their implementations.  Abstract classes allow the methods of a class to be
defined without specifying an implementation of those methods.  An abstract
class can never be instantiated because its behaviour is undefined.  Only
concrete (non-abstract) extensions of an abstract class can be instantiated;
these must define an implementation for each abstract method.

The Oberon-2 language lacks a mechanism for abstract classes, so typically,
abstract classes are simulated using concrete types: @code{HALT} statements
are used in the body of ``abstract'' methods, so that a run-time exception
occurs if the class is accidentally instantiated and an abstract method is
called.  This is not a safe solution to the problem.  To preserve the
semantics of abstract classes, it is expected that the compiler will:

@enumerate
@item
Allow the programmer to differentiate between abstract and concrete
classes in declarations.
@item
Prohibit the instantiation of abstract classes.
@item
Prohibit the calling of abstract methods.
@item
Ensure that concrete classes implement all the required abstract methods.
@end enumerate

This section describes an extension to the OOC compiler that supports these
essential features.  The extension does not change the Oberon-2 language
itself, but instead uses the @samp{ABSTRACT} flag to distinguish abstract
classes and methods.  Compilers that do not recognise the flag should ignore
it and compile the code as normal.  Code that compiles correctly using the
OOC abstract classes model should work correctly under other Oberon-2
compilers.

The following rules describe the semantics of abstract classes, as
implemented by the compiler:

@enumerate
@item
Any record type may be declared with the @samp{ABSTRACT} flag.  Such
abstract records have the following properties:

@itemize @bullet
@item
It is illegal to declare a variable, record field, or array of an abstract
type.

@item
@samp{NEW(p)} is illegal, if @samp{p} is a pointer variable whose base type
is abstract.

@item
It is legal to use an abstract type as the base type for pointer and record
declarations.

@item
An abstract type can be used for a parameter, receiver, or result type of a
procedure.
@end itemize

@item
A procedure bound to an abstract record may be declared with the
@samp{ABSTRACT} flag.  The body of such a procedure must be empty and must
not contain a @code{BEGIN} statement.

@item
When a non-abstract record extends an abstract record, it @emph{must}
implement each abstract method inherited from its base type.  The compiler
generates an error for each non-implemented abstract procedure.

@item
It is illegal to call an abstract method via a super call.

@item
Any method marked @samp{ABSTRACT} must have an export flag.
@end enumerate

These rules ensure that non-implemented methods are never called, which
ensures safety of the system.  OOC permits classes to be partially abstract,
that is, to have a mixture of concrete and abstract methods.  OOC also
permits concrete classes to have abstract extensions.  The following example
illustrates some of the features of this mechanism:

@smallexample
MODULE Abstract [OOC_EXTENSIONS];

TYPE
  PtrA = POINTER TO A;
  A* = RECORD [ABSTRACT] END;   (* abstract type *)

  PtrB = POINTER TO B;
  B* = RECORD (A) END;          (* concrete extension of A *)

VAR
  vA: A;                       (* illegal! *)
  pA: PtrA;
  pB: PtrB;

(* abstract definition of F *)
PROCEDURE (VAR v: A) [ABSTRACT] F*;
  END F;

(* implementation of F *)
PROCEDURE (VAR v: B) F*;
  BEGIN
  END F;

BEGIN
  NEW(pA);                      (* illegal! *)
  NEW(pB);
  pB.F;
  pB.F^;                        (* illegal! *)
  pA := pB;
  pA.F;
END Abstract.
@end smallexample

Another example of the use of abstract classes is the module @samp{Channel}
(@pxref{Channel}).  All record types and most of the methods defined in this
module are declared abstract.


@node NO_COPY, , ABSTRACT, Language Extensions
@subsection Avoiding Local Copies of Value Parameters
@cindex NO_COPY flag

When invoking a procedure, local copies are created for all arguments that
are passed to value parameters.  If the value parameter is a large array or
an open array parameter, allocating storage for the variable and creating
the copy can be expensive in both stack space and execution time.  During
compile-time, OOC tries to detect situations where it can avoid the local
copy and access the original variable instead.  The algorithm used cannot
detect all situations where this is possible; it must conservatively choose
in favor of a local copy if there is the slightest chance that omitting it
would change the semantics of the procedure.  This can be overidden by the
programmer by setting the flag @samp{NO_COPY} for the value parameter in
question.  The flag can be applied only to value parameters of structured
type.

@emph{Example:}  

@smallexample
MODULE Out [OOC_EXTENSIONS];

PROCEDURE String* (s[NO_COPY]: ARRAY OF CHAR);
  BEGIN
    writer. WriteString (s)
  END String;

END Out.  
@end smallexample

Because the procedure @samp{Out.String} is just a wrapper for the channel's
@samp{WriteString} function, there is no need to create a local copy of any
arguments passed to parameter @samp{s}.

If used without care, the flag @samp{NO_COPY} can create a parameter that is
neither variable nor value.  It should be applied only in situations where

@itemize @bullet
@item
the parameter is not modified during execution of the procedure, and
@item
a variable passed to the parameter cannot be modified by other means, like
direct access or through another variable parameter.
@end itemize

An example for a situation where @samp{NO_COPY} cannot be used is OOC's
implementation of @samp{Strings.Append}.  If the parameter @samp{source}
would be marked with @samp{NO_COPY}, the procedure would break for calls
that use the same variable for both @samp{source} and @samp{destination}.


@node Illegal Operations, , Language Extensions, Language
@section Illegal Operations
@cindex illegal operations
@cindex run-time checks

During the execution of a program, it is possible for an operation to be
performed that is either illegal or that leaves the program in an undefined
state.  This sort of operation is usually not intended by the programmer,
and should therefore be brought to his attention.  For this reason, a
typical Oberon-2 run-time system provides mechanisms to detect illegal or
undefined operations and report them to the user.

For OOC, an invalid operation is signaled by the facilities defined in
module @code{Exception} (@pxref{Exception Handling}).  If detected, such an
operation will raise an exception of source @code{Exception.runtime} with an
exception number from the list defined in @code{Exception}.  If the raised
exception is not handled by the program, it will cause the run-time system
to emit an appropriate error message and terminate the program.

The following is a list of exception numbers, which indicate run-time errors
and are applicable to source @code{Exception.runtime}:

@table @samp
@item derefOfNIL
Indicates an attempt to dereference a pointer or procedure variable that
holds a value of @code{NIL}.  Such a dereference can happen as a result of
one of the following:

@itemize @bullet
@item
during an explicit dereference operation @code{^} as part of a designator
@item
when accessing a record field or an array element of a heap object
@item
when applying a type test or a type guard
@item
when making a procedure call through a procedure variable.
@end itemize

@item indexOutOfRange
The value used in an array designator's index selector is not in the range
@samp{[0..len-1]}, where @samp{len} denotes the array's length.

@item elementOutOfRange
Triggered if one of the set operations @code{IN}, @code{INCL}, or
@code{EXCL} is given an element value that is not a member of the set type
being used.  Note that an element of the standard set type @code{SET} has to
be in the range @samp{0..31}.

@item realDivByZero
Signaled when an operation @samp{x / y} is performed when @samp{y} is zero.

@item integerDivByZero
Signaled when an operation @samp{x DIV y} or @samp{x MOD y} is performed
when @samp{y} is zero.

@item realOverflow
Raised whenever a real operation produces a value that cannot be represented
in the target type format.  @emph{Please note}: It is possible that floating
point calculations are performed internally with higher precision than the
type of their arguments.  This means that the overflow may occur only when
attempting to write the result back into a memory using the smaller type of
the arguments.  Also, as a note of warning, intermediate results of
operations may overflow unnoticed as long as the end result can be stored in
the required representation.

@item integerOverflow
Signals that an integer operation has produced a result that cannot be
represented in the target type format.

@item endOfFunction
Raised when the evaluation of a function procedure reaches the end of the
procedure without encountering a @code{RETURN} statement.

@item noMatchingLabel
Raised if the selection value of a @code{CASE} does not match any label of
the listed branches and there is no @code{ELSE} part.

@item typeGuardFailed
Raised when a type guard does not hold during evaluation of a designator.
This means that the dynamic type of the guarded variable differs from the
type it is guarded against.  Note that an @samp{derefOfNil} exception is
raised if the tested variable is a pointer with a value of @code{NIL}.

@item typeAssertFailed
A @dfn{type assertion} is an implicit type guard added for the left side of
assignments dealing with record values.  It ensures that the dynamic type of
the target is equal to its static type.  If the types differ, an
@samp{typeAssertFailed} exception is raised.

@item noValidGuard
Raised if none of the guards of a @code{WITH} statement is valid and there
is no @code{ELSE} part.

@item stackOverflow
The data of procedure activations is stored in a special memory area called
the @dfn{stack}.  If too much data is pushed onto the stack, or too many
procedures are active at the same time, the stack overflows and program
execution cannot continue; this raises an @samp{stackOverflow} exception.

@item illegalLength
Raised if the predefined procedure @code{NEW} is invoked for an open array
pointer type with a negative value for one of the array's lengths.  This
run-time check cannot be disabled.

@item outOfMemory
Raised if a call to @code{NEW} or @code{SYSTEM.NEW} failed because of
insufficient memory.  @code{NEW} guarantees that the pointer variable will
refer to a valid heap object after completion; if this fails, an
@code{outOfMemory} exception is raised.  This run-time check cannot be
disabled.
@end table

During compilation, each run-time check (except the checks performed for
@code{NEW}) can be enabled or disabled by a pragma variable.  If the
corresponding pragma variable is set to @code{TRUE}, appropriate code is
generated to catch the class of errors in question.  If it is @code{FALSE},
and such an error occurs at run-time, it might go by unnoticed, lead to
unexpected program results, or even cause program termination in the form of
a core dump.  

The performance impact of run-time checks depends mostly on the target
system.  Testing for an illegal operation might be done efficiently on one
target architecture, but be very costly on another.  Not all run-time checks
are supported by all OOC compilers.  For example, @code{oo2c} does not
support overflow checks for integer or real operations.

A special note should be made about operations on strings.  Recall that the
Oberon-2 definition of a string is a character array that contains the
character @code{0X} as a terminator.  Oberon-2 string operations
(@code{COPY}, @samp{=}, @samp{#}, @samp{<}, etc.) are undefined for
unterminated character arrays.  Here OOC follows the Oakwood guidelines, and
does not provide any checks to guard against such undefined operations.  For
instance, if the source of a @code{COPY} operation is not terminated by a
character @code{0X}, the contents of the target array are undefined after
completion.

